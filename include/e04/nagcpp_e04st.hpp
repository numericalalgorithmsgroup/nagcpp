// Header for nagcpp::opt::handle_solve_ipopt (e04st)

// Copyright 2022, Numerical Algorithms Group Ltd, Oxford, UK.
// Generated by cpp-ft-wrapper.xsl
// Version 28.5.0.0
#ifndef NAGCPP_E04ST_HPP
#define NAGCPP_E04ST_HPP

#include "utility/nagcpp_callback_handling.hpp"
#include "utility/nagcpp_consts.hpp"
#include "utility/nagcpp_data_handling.hpp"
#include "utility/nagcpp_engine_routines.hpp"
#include "utility/nagcpp_engine_types.hpp"
#include "utility/nagcpp_error_handler.hpp"
#include "utility/nagcpp_utility_comm.hpp"
#include "utility/nagcpp_utility_macros.hpp"
#include "utility/nagcpp_utility_optional.hpp"
#include "utility/nagcpp_utility_print_rec.hpp"

namespace nagcpp {
  namespace opt {
    // handle_solve_ipopt (e04st)
    // Interior point method (IPM) for sparse nonlinear programming (NLP) problems.
    // Note: this function uses optional algorithmic parameters, see also:
    // opt::handle_opt_set (e04zm), opt::handle_opt_get (e04zn).
    // opt::handle_solve_ipopt (e04st) is a solver from the NAG optimization
    // modelling suite for constrained large-scale Nonlinear Programming (NLP)
    // problems.
    // It is an interior point method optimization solver based on the IPOPT
    // software package.

    // parameters:
    //   comm: opt::CommE04RA, scalar
    //     Communication structure.
    //     An object of either the derived class opt::CommE04RA or its base class
    //     utility::NoneCopyableComm can be supplied.
    //     It is recommended that the derived class is used. If the base class is
    //     supplied it must
    //     first be initialized via a call to opt::handle_init (e04ra).
    //   u: double, array, shape(nnzu)
    //     Optionally, on entry: the input of u is reserved for future releases of
    //     the NAG Library and it is ignored at the moment.
    //     Note: if nnzu > 0, u holds Lagrange multipliers (dual variables) for the
    //     constraints.
    //     On exit, if not null on entry: the final value of Lagrange multipliers
    //     (z,lambda)
    //   rinfo: double, array, shape(100)
    //     On exit, if not null on entry: error measures and various indicators at
    //     the end of the final iteration as given in the list below
    //   stats: double, array, shape(100)
    //     On exit, if not null on entry: solver statistics at the end of the final
    //     iteration as given in the list below
    //   objfun: void, function
    //     objfun must calculate the value of the nonlinear objective function f(x)
    //     at a specified value of the n-element vector of x variables

    //     parameters:
    //       x: double, array, shape(nvar)
    //         The vector x of variable values at which the objective function is to be
    //         evaluated
    //       fx: double, scalar
    //         On exit: the value of the objective function at x
    //       inform: types::f77_integer, scalar
    //         On entry: a non-negative value
    //         On exit: must be set to a value describing the action to be taken by the
    //         solver on return from objfun
    //   objgrd: void, function
    //     objgrd must calculate the values of the nonlinear objective function
    //     gradients df/dx at a specified value of the n-element vector of x variables

    //     parameters:
    //       x: double, array, shape(nvar)
    //         The vector x of variable values at which the objective function gradient
    //         is to be evaluated
    //       fdx: double, array, shape(nnzfd)
    //         On entry: the elements should only be assigned and not referenced
    //         On exit: the values of the nonzero elements in the sparse gradient
    //         vector of the objective function, in the order specified by idxfd in a
    //         previous call to opt::handle_set_nlnobj (e04rg)
    //       inform: types::f77_integer, scalar
    //         On entry: a non-negative value
    //         On exit: must be set to a value describing the action to be taken by the
    //         solver on return from objgrd the value of
    //   confun: void, function
    //     confun must calculate the values of the m_g-element vector g_i(x) of
    //     nonlinear constraint functions at a specified value of the n-element
    //     vector of x variables

    //     parameters:
    //       x: double, array, shape(nvar)
    //         The vector x of variable values at which the constraint functions are to
    //         be evaluated
    //       ncnln: types::f77_integer, scalar
    //         m_g, the number of nonlinear constraints, as specified in an earlier
    //         call to opt::handle_set_nlnconstr (e04rk)
    //       gx: double, array, shape(ncnln)
    //         On exit: the m_g values of the nonlinear constraint functions at x
    //       inform: types::f77_integer, scalar
    //         On entry: a non-negative value
    //         On exit: must be set to a value describing the action to be taken by the
    //         solver on return from confun
    //   congrd: void, function
    //     congrd must calculate the nonzero values of the sparse Jacobian of the
    //     nonlinear constraint functions dg_i/dx at a specified value of the
    //     n-element vector of x variables

    //     parameters:
    //       x: double, array, shape(nvar)
    //         The vector x of variable values at which the Jacobian of the constraint
    //         functions is to be evaluated
    //       gdx: double, array, shape(nnzgd)
    //         On entry: the elements should only be assigned and not referenced
    //         On exit: the nonzero values of the Jacobian of the nonlinear
    //         constraints, in the order specified by irowgd and icolgd in an earlier
    //         call to opt::handle_set_nlnconstr (e04rk)
    //       inform: types::f77_integer, scalar
    //         On entry: a non-negative value
    //         On exit: must be set to a value describing the action to be taken by the
    //         solver on return from congrd
    //   hess: void, function
    //     hess must calculate the nonzero values of one of a set of second
    //     derivative quantities

    //     parameters:
    //       x: double, array, shape(nvar)
    //         The vector x of variable values at which the Hessian functions are to be
    //         evaluated
    //       idf: types::f77_integer, scalar
    //         Specifies the quantities to be computed in hx
    //       sigma: double, scalar
    //         If idf = -1, the value of the sigma quantity in the definition of the
    //         Hessian of the Lagrangian
    //       lamda: double, array, shape(ncnln)
    //         If idf = -1, the values of the lambda_i quantities in the definition of
    //         the Hessian of the Lagrangian
    //       hx: double, array, shape(nnzh)
    //         On entry: the elements should only be assigned and not referenced
    //         On exit: the nonzero values of the requested Hessian evaluated at x
    //       inform: types::f77_integer, scalar
    //         On entry: a non-negative value
    //         On exit: must be set to a value describing the action to be taken by the
    //         solver on return from hess
    //   monit: void, function
    //     monit is provided to enable you to monitor the progress of the optimization

    //     parameters:
    //       x: double, array, shape(nvar)
    //         x^i, the values of the decision variables x at the current iteration
    //       u: double, array, shape(nnzu)
    //         If nnzu > 0, u holds the values of Lagrange multipliers (dual variables)
    //         for the constraints at the current iteration
    //       rinfo: double, array, shape(100)
    //         Error measures and various indicators at the end of the current
    //         iteration as described in Description of the Printed Output
    //       stats: double, array, shape(100)
    //         Solver statistics at the end of the current iteration the number of
    //         backtracking trial steps taken
    //   nvar: types::f77_integer, scalar
    //     n, the current number of decision variables x in the model
    //   x: double, array, shape(nvar)
    //     On entry: x^0, the initial estimates of the variables x
    //     On exit: the final values of the variables x
    //   opt: opt::OptionalE04ST
    //     Optional parameter container, derived from utility::Optional.
    //     contains:
    //       fail: error_handler::ErrorHandler

    // other parameters:
    //   Defaults: valueless
    //     This special keyword may be used to reset all options to their default
    //     values
    //   Hessian Mode: char
    //     Default = "AUTO"
    //     This parameter specifies whether the Hessian will be user-supplied (in hx)
    //     or approximated by opt::handle_solve_ipopt (e04st) using a limited-memory
    //     quasi-Newton L-BFGS method
    //   Infinite Bound Size: double
    //     Default = 10^20
    //     This defines the "infinite" bound bigbnd in the definition of the problem
    //     constraints
    //   Monitoring File: types::f77_integer
    //     Default = -1
    //     If i >= 0, the unit number for the secondary (monitoring) output
    //   Monitoring Level: types::f77_integer
    //     Default = 4
    //     This parameter sets the amount of information detail that will be printed
    //     by the solver to the secondary output
    //   Matrix Ordering: char
    //     Default = "AUTO"
    //     This parameter specifies the ordering to be used by the internal sparse
    //     linear algebra solver
    //   Outer Iteration Limit: types::f77_integer
    //     Default = 100
    //     The maximum number of iterations to be performed by
    //     opt::handle_solve_ipopt (e04st)
    //   Print File: types::f77_integer
    //     Default = advisory message unit number
    //     If i >= 0, the unit number for the primary output of the solver
    //   Print Level: types::f77_integer
    //     Default = 2
    //     This parameter defines how detailed information should be printed by the
    //     solver to the primary output
    //   Print Options: char
    //     Default = "YES"
    //     If "Print Options" = "YES", a listing of options will be printed to the
    //     primary output
    //   Print Solution: char
    //     Default = "NO"
    //     If "Print Solution" = "X", the final values of the primal variables are
    //     printed on the primary and secondary outputs
    //   Stats Time: char
    //     Default = "NO"
    //     This parameter allows you to turn on timings of various parts of the
    //     algorithm to give a better overview of where most of the time is spent
    //   Stop Tolerance 1: double
    //     Default = max(10^-6, sqrt(epsilon))
    //     This option sets the value epsilon_tol of (5) which is used for optimality
    //     and complementarity tests from KKT conditions
    //   Task: char
    //     Default = "MINIMIZE"
    //     This parameter specifies the required direction of the optimization
    //   Time Limit: double
    //     Default = 10^6
    //     A limit to the number of seconds that the solver can use to solve one
    //     problem
    //   Verify Derivatives: char
    //     Default = "NO"
    //     This parameter specifies whether the function should perform numerical
    //     checks on the consistency of the user-supplied functions

    // error_handler::ErrorException
    //   (errorid -199)
    //     opt::handle_solve_ipopt (e04st) is not available in this implementation.
    //   (errorid 1)
    //     comm.handle has not been initialized.
    //   (errorid 1)
    //     comm.handle does not belong to the NAG optimization modelling suite,
    //     has not been initialized properly or is corrupted.
    //   (errorid 1)
    //     comm.handle has not been initialized properly or is corrupted.
    //   (errorid 2)
    //     The problem is already being solved.
    //   (errorid 2)
    //     This solver does not support the model defined in the handle.
    //   (errorid 4)
    //     On entry, nvar = <value>,
    //     expected value = <value>.
    //     Constraint: nvar must match the current number of variables
    //     of the model in the comm.handle.
    //   (errorid 5)
    //     On entry, nnzu = <value>.
    //     Constraint: nnzu = <value> or 0.
    //   (errorid 5)
    //     On entry, nnzu = <value>.
    //     Constraint: no constraints present, so nnzu must be 0.
    //   (errorid 6)
    //     On entry, a nonlinear objective function has been defined
    //     but no objective Hessian sparsity structure has been defined
    //     through opt::handle_set_nlnhess (e04rl).
    //   (errorid 6)
    //     On entry, a nonlinear constraint function has been defined
    //     but no constraint Hessian sparsity structure has been defined
    //     through opt::handle_set_nlnhess (e04rl), for constraint number <value>.
    //   (errorid 7)
    //     Either change the option "Hessian Mode" or
    //     provide a proper hess function.
    //   (errorid 7)
    //     Please provide a proper objfun function.
    //   (errorid 7)
    //     Please provide a proper objgrd function.
    //   (errorid 7)
    //     Please provide a proper confun function.
    //   (errorid 7)
    //     Please provide a proper congrd function.
    //   (errorid 23)
    //     The solver terminated with not enough degrees of freedom.
    //   (errorid 23)
    //     The solver terminated due to an invalid problem definition.
    //   (errorid 23)
    //     The solver terminated due to an invalid option.
    //   (errorid 51)
    //     The solver detected an infeasible problem.
    //   (errorid 54)
    //     The solver terminated due to diverging iterates.
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     Supplied argument has <value> dimensions.
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     Supplied argument was a vector of size <value>.
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     The size for the supplied array could not be ascertained.
    //   (errorid 10602)
    //     On entry, the raw data component of <value> is null.
    //   (errorid 10603)
    //     On entry, unable to ascertain a value for <value>.
    //   (errorid 10605)
    //     On entry, the communication class <value> has not been initialized
    //     correctly.
    //   (errorid 10703)
    //     An exception was thrown during IO (writing).
    //   (errorid -99)
    //     An unexpected error has been triggered by this routine.
    //   (errorid -399)
    //     Your licence key may have expired or may not have been installed correctly.
    //   (errorid -999)
    //     Dynamic memory allocation failed.

    // error_handler::CallbackEarlyTermination
    //   (errorid 20)
    //     User requested termination during a monitoring step.

    // error_handler::WarningException
    //   (errorid 22)
    //     Maximum number of iterations exceeded.
    //   (errorid 23)
    //     The solver terminated after failure in the restoration phase.
    //   (errorid 23)
    //     The solver terminated after an error in the step computation.
    //   (errorid 23)
    //     The solver terminated after the maximum time allowed was exceeded.
    //   (errorid 24)
    //     The solver terminated after the search direction became too small.
    //   (errorid 25)
    //     Invalid number detected in user function.
    //   (errorid 50)
    //     The solver reports NLP solved to acceptable level.

    // error_handler::CallbackException
    //   (errorid 10701)
    //     An exception was thrown in a callback.
    //   (errorid 10702)
    //     The memory address for an array in a callback has changed.

    extern "C" {
#ifndef E04STFT_OBJFUN
#define E04STFT_OBJFUN                                                    \
  std::function<void(                                                     \
    const data_handling::CallbackAddresses *, types::engine_data &,       \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    double &, types::f77_integer &)>
#endif

#if defined(_WIN32) && defined(USE_STDCALL)
#define e04stvt_(en_data, nvar, x, fx, inform, iuser, ruser) \
  E04STVT(en_data, nvar, x, fx, inform, iuser, ruser)
#elif defined(_WIN32) || defined(_WIN64)
#define e04stvt_ E04STVT
#else
#define E04STVT e04stvt_
#endif
    void NAG_CALL E04STVT(types::engine_data &en_data,
                          const types::f77_integer &nvar, const double x[],
                          double &fx, types::f77_integer &inform, void *iuser,
                          void *ruser);

#ifndef E04STFT_OBJFUNH
#define E04STFT_OBJFUNH                                                  \
  void(NAG_CALL * objfunh)(const E04STFT_OBJFUN &, types::engine_data &, \
                           const types::f77_integer &, const double[],   \
                           double &, types::f77_integer &, void *, void *)
#endif

#ifndef E04STFT_OBJGRD
#define E04STFT_OBJGRD                                                    \
  std::function<void(                                                     \
    const data_handling::CallbackAddresses *, types::engine_data &,       \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &,    \
    types::f77_integer &)>
#endif

#if defined(_WIN32) && defined(USE_STDCALL)
#define e04stwt_(en_data, nvar, x, nnzfd, fdx, inform, iuser, ruser) \
  E04STWT(en_data, nvar, x, nnzfd, fdx, inform, iuser, ruser)
#elif defined(_WIN32) || defined(_WIN64)
#define e04stwt_ E04STWT
#else
#define E04STWT e04stwt_
#endif
    void NAG_CALL E04STWT(types::engine_data &en_data,
                          const types::f77_integer &nvar, const double x[],
                          const types::f77_integer &nnzfd, double fdx[],
                          types::f77_integer &inform, void *iuser, void *ruser);

#ifndef E04STFT_OBJGRDH
#define E04STFT_OBJGRDH                                                  \
  void(NAG_CALL * objgrdh)(const E04STFT_OBJGRD &, types::engine_data &, \
                           const types::f77_integer &, const double[],   \
                           const types::f77_integer &, double[],         \
                           types::f77_integer &, void *, void *)
#endif

#ifndef E04STFT_CONFUN
#define E04STFT_CONFUN                                                    \
  std::function<void(                                                     \
    const data_handling::CallbackAddresses *, types::engine_data &,       \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    const types::f77_integer,                                             \
    utility::array1D<double, data_handling::ArgIntent::IntentOUT> &,      \
    types::f77_integer &)>
#endif

#if defined(_WIN32) && defined(USE_STDCALL)
#define e04stxt_(en_data, nvar, x, ncnln, gx, inform, iuser, ruser) \
  E04STXT(en_data, nvar, x, ncnln, gx, inform, iuser, ruser)
#elif defined(_WIN32) || defined(_WIN64)
#define e04stxt_ E04STXT
#else
#define E04STXT e04stxt_
#endif
    void NAG_CALL E04STXT(types::engine_data &en_data,
                          const types::f77_integer &nvar, const double x[],
                          const types::f77_integer &ncnln, double gx[],
                          types::f77_integer &inform, void *iuser, void *ruser);

#ifndef E04STFT_CONFUNH
#define E04STFT_CONFUNH                                                  \
  void(NAG_CALL * confunh)(const E04STFT_CONFUN &, types::engine_data &, \
                           const types::f77_integer &, const double[],   \
                           const types::f77_integer &, double[],         \
                           types::f77_integer &, void *, void *)
#endif

#ifndef E04STFT_CONGRD
#define E04STFT_CONGRD                                                    \
  std::function<void(                                                     \
    const data_handling::CallbackAddresses *, types::engine_data &,       \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &,    \
    types::f77_integer &)>
#endif

#if defined(_WIN32) && defined(USE_STDCALL)
#define e04styt_(en_data, nvar, x, nnzgd, gdx, inform, iuser, ruser) \
  E04STYT(en_data, nvar, x, nnzgd, gdx, inform, iuser, ruser)
#elif defined(_WIN32) || defined(_WIN64)
#define e04styt_ E04STYT
#else
#define E04STYT e04styt_
#endif
    void NAG_CALL E04STYT(types::engine_data &en_data,
                          const types::f77_integer &nvar, const double x[],
                          const types::f77_integer &nnzgd, double gdx[],
                          types::f77_integer &inform, void *iuser, void *ruser);

#ifndef E04STFT_CONGRDH
#define E04STFT_CONGRDH                                                  \
  void(NAG_CALL * congrdh)(const E04STFT_CONGRD &, types::engine_data &, \
                           const types::f77_integer &, const double[],   \
                           const types::f77_integer &, double[],         \
                           types::f77_integer &, void *, void *)
#endif

#ifndef E04STFT_HESS
#define E04STFT_HESS                                                      \
  std::function<void(                                                     \
    const data_handling::CallbackAddresses *, types::engine_data &,       \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    const types::f77_integer, const double,                               \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &,    \
    types::f77_integer &)>
#endif

#if defined(_WIN32) && defined(USE_STDCALL)
#define e04stzt_(en_data, nvar, x, ncnln, idf, sigma, lamda, nnzh, hx, inform, \
                 iuser, ruser)                                                 \
  E04STZT(en_data, nvar, x, ncnln, idf, sigma, lamda, nnzh, hx, inform, iuser, \
          ruser)
#elif defined(_WIN32) || defined(_WIN64)
#define e04stzt_ E04STZT
#else
#define E04STZT e04stzt_
#endif
    void NAG_CALL E04STZT(types::engine_data &en_data,
                          const types::f77_integer &nvar, const double x[],
                          const types::f77_integer &ncnln,
                          const types::f77_integer &idf, const double &sigma,
                          const double lamda[], const types::f77_integer &nnzh,
                          double hx[], types::f77_integer &inform, void *iuser,
                          void *ruser);

#ifndef E04STFT_HESSH
#define E04STFT_HESSH                                                          \
  void(NAG_CALL * hessh)(const E04STFT_HESS &, types::engine_data &,           \
                         const types::f77_integer &, const double[],           \
                         const types::f77_integer &,                           \
                         const types::f77_integer &, const double &,           \
                         const double[], const types::f77_integer &, double[], \
                         types::f77_integer &, void *, void *)
#endif

#ifndef E04STFT_MONIT
#define E04STFT_MONIT                                                     \
  std::function<void(                                                     \
    const data_handling::CallbackAddresses *, types::engine_data &,       \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &)>
#endif

#if defined(_WIN32) && defined(USE_STDCALL)
#define e04stut_(en_data, nvar, x, nnzu, u, inform, rinfo, stats, iuser, \
                 ruser)                                                  \
  E04STUT(en_data, nvar, x, nnzu, u, inform, rinfo, stats, iuser, ruser)
#elif defined(_WIN32) || defined(_WIN64)
#define e04stut_ E04STUT
#else
#define E04STUT e04stut_
#endif
    void NAG_CALL E04STUT(types::engine_data &en_data,
                          const types::f77_integer &nvar, const double x[],
                          const types::f77_integer &nnzu, const double u[],
                          types::f77_integer &inform, const double rinfo[],
                          const double stats[], void *iuser, void *ruser);

#ifndef E04STFT_MONITH
#define E04STFT_MONITH                                                 \
  void(NAG_CALL * monith)(const E04STFT_MONIT &, types::engine_data &, \
                          const types::f77_integer &, const double[],  \
                          const types::f77_integer &, const double[],  \
                          types::f77_integer &, const double[],        \
                          const double[], void *, void *)
#endif

#if defined(_WIN32) && defined(USE_STDCALL)
#define e04stft_(en_data, print_rec, print_rech, handle, objfun, objfunh,     \
                 objgrd, objgrdh, confun, confunh, congrd, congrdh, hess,     \
                 hessh, monit, monith, nvar, x, nnzu, u, rinfo, stats, iuser, \
                 ruser, errbuf, ifail, errbuf_length)                         \
  E04STFT(en_data, print_rec, print_rech, handle, objfun, objfunh, objgrd,    \
          objgrdh, confun, confunh, congrd, congrdh, hess, hessh, monit,      \
          monith, nvar, x, nnzu, u, rinfo, stats, iuser, ruser, errbuf,       \
          errbuf_length, ifail)
#elif defined(_WIN32) || defined(_WIN64)
#define e04stft_ E04STFT
#else
#define E04STFT e04stft_
#endif
    extern void NAG_CALL
      E04STFT(types::engine_data &en_data, void *print_rec, NAG_PRINT_RECH,
              void *handle, const E04STFT_OBJFUN &, E04STFT_OBJFUNH,
              const E04STFT_OBJGRD &, E04STFT_OBJGRDH, const E04STFT_CONFUN &,
              E04STFT_CONFUNH, const E04STFT_CONGRD &, E04STFT_CONGRDH,
              const E04STFT_HESS &, E04STFT_HESSH, const E04STFT_MONIT &,
              E04STFT_MONITH, const types::f77_integer &nvar, double x[],
              const types::f77_integer &nnzu, double u[], double rinfo[],
              double stats[], void *iuser, void *ruser,
              char *errbuf NAG_STDCALL_LEN(errbuf_length),
              types::f77_integer &ifail NAG_NSTDCALL_LEN(errbuf_length));
    }

    class CommE04RA;

    class OptionalE04ST : public utility::Optional {
    public:
      OptionalE04ST() : Optional() {}
      template <typename COMM, typename OBJFUN, typename OBJGRD,
                typename CONFUN, typename CONGRD, typename HESS, typename MONIT,
                typename X, typename U, typename RINFO, typename STATS>
      friend void handle_solve_ipopt(COMM &comm, OBJFUN &&objfun,
                                     OBJGRD &&objgrd, CONFUN &&confun,
                                     CONGRD &&congrd, HESS &&hess,
                                     MONIT &&monit, X &&x, U &&u, RINFO &&rinfo,
                                     STATS &&stats, opt::OptionalE04ST &opt);
    };

    void e04st_objfunh(const E04STFT_OBJFUN &objfun,
                       types::engine_data &en_data,
                       const types::f77_integer &nvar, const double *x,
                       double &fx, types::f77_integer &inform, void *iuser,
                       void *ruser) {
      error_handler::ExceptionPointer *ep =
        static_cast<error_handler::ExceptionPointer *>(en_data.wrapptr1);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_x(
        x, nvar);
      data_handling::CallbackAddresses *callbacks =
        static_cast<data_handling::CallbackAddresses *>(en_data.wrapptr2);

      try {
        if (static_cast<bool>((*callbacks).address[0])) {
          objfun(callbacks, en_data, local_x, fx, inform);
        } else {
          e04stvt_(en_data, nvar, x, fx, inform, iuser, ruser);
        }
      } catch (...) {
        // callback threw an exception
        en_data.hlperr = error_handler::HLPERR_USER_EXCEPTION;
        ep->eptr = std::current_exception();
      }

      if ((x != local_x.data())) {
        // address of an array changed
        en_data.hlperr = error_handler::HLPERR_ARRAY_POINTER_CHANGED;
        return;
      }
    }

    template <typename OBJFUN_X, typename OBJFUN>
    struct e04st_objfun_cs {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        double &fx, types::f77_integer &inform) {
        OBJFUN &objfun =
          *((typename std::remove_reference<OBJFUN>::type *)(*callbacks)
              .address[0]);

        auto local_x = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, OBJFUN_X>(x);

        objfun(local_x.get(), fx, inform);
      }
    };

    template <>
    struct e04st_objfun_cs<std::nullptr_t, std::nullptr_t> {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        double &fx, types::f77_integer &inform) {
        return;
      }
    };

    void e04st_objgrdh(const E04STFT_OBJGRD &objgrd,
                       types::engine_data &en_data,
                       const types::f77_integer &nvar, const double *x,
                       const types::f77_integer &nnzfd, double *fdx,
                       types::f77_integer &inform, void *iuser, void *ruser) {
      error_handler::ExceptionPointer *ep =
        static_cast<error_handler::ExceptionPointer *>(en_data.wrapptr1);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_x(
        x, nvar);
      utility::array1D<double, data_handling::ArgIntent::IntentINOUT> local_fdx(
        fdx, nnzfd);
      data_handling::CallbackAddresses *callbacks =
        static_cast<data_handling::CallbackAddresses *>(en_data.wrapptr2);

      try {
        if (static_cast<bool>((*callbacks).address[1])) {
          objgrd(callbacks, en_data, local_x, local_fdx, inform);
        } else {
          e04stwt_(en_data, nvar, x, nnzfd, fdx, inform, iuser, ruser);
        }
      } catch (...) {
        // callback threw an exception
        en_data.hlperr = error_handler::HLPERR_USER_EXCEPTION;
        ep->eptr = std::current_exception();
      }

      if ((x != local_x.data()) && (fdx != local_fdx.data())) {
        // address of an array changed
        en_data.hlperr = error_handler::HLPERR_ARRAY_POINTER_CHANGED;
        return;
      }
    }

    template <typename OBJGRD_X, typename OBJGRD_FDX, typename OBJGRD>
    struct e04st_objgrd_cs {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &fdx,
        types::f77_integer &inform) {
        OBJGRD &objgrd =
          *((typename std::remove_reference<OBJGRD>::type *)(*callbacks)
              .address[1]);

        auto local_x = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, OBJGRD_X>(x);
        auto local_fdx = data_handling::convert_nag_array_to_user<
          utility::array1D<double, data_handling::ArgIntent::IntentINOUT>,
          data_handling::ArgIntent::IntentINOUT, OBJGRD_FDX>(fdx);

        objgrd(local_x.get(), local_fdx.get(), inform);
      }
    };

    template <>
    struct e04st_objgrd_cs<std::nullptr_t, std::nullptr_t, std::nullptr_t> {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &fdx,
        types::f77_integer &inform) {
        return;
      }
    };

    void e04st_confunh(const E04STFT_CONFUN &confun,
                       types::engine_data &en_data,
                       const types::f77_integer &nvar, const double *x,
                       const types::f77_integer &ncnln, double *gx,
                       types::f77_integer &inform, void *iuser, void *ruser) {
      error_handler::ExceptionPointer *ep =
        static_cast<error_handler::ExceptionPointer *>(en_data.wrapptr1);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_x(
        x, nvar);
      utility::array1D<double, data_handling::ArgIntent::IntentOUT> local_gx(
        gx, ncnln);
      data_handling::CallbackAddresses *callbacks =
        static_cast<data_handling::CallbackAddresses *>(en_data.wrapptr2);

      try {
        if (static_cast<bool>((*callbacks).address[2])) {
          confun(callbacks, en_data, local_x, ncnln, local_gx, inform);
        } else {
          e04stxt_(en_data, nvar, x, ncnln, gx, inform, iuser, ruser);
        }
      } catch (...) {
        // callback threw an exception
        en_data.hlperr = error_handler::HLPERR_USER_EXCEPTION;
        ep->eptr = std::current_exception();
      }

      if ((x != local_x.data()) && (gx != local_gx.data())) {
        // address of an array changed
        en_data.hlperr = error_handler::HLPERR_ARRAY_POINTER_CHANGED;
        return;
      }
    }

    template <typename CONFUN_X, typename CONFUN_GX, typename CONFUN>
    struct e04st_confun_cs {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        const types::f77_integer ncnln,
        utility::array1D<double, data_handling::ArgIntent::IntentOUT> &gx,
        types::f77_integer &inform) {
        CONFUN &confun =
          *((typename std::remove_reference<CONFUN>::type *)(*callbacks)
              .address[2]);

        auto local_x = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, CONFUN_X>(x);
        auto local_gx = data_handling::convert_nag_array_to_user<
          utility::array1D<double, data_handling::ArgIntent::IntentOUT>,
          data_handling::ArgIntent::IntentOUT, CONFUN_GX>(gx);

        confun(local_x.get(), ncnln, local_gx.get(), inform);
      }
    };

    template <>
    struct e04st_confun_cs<std::nullptr_t, std::nullptr_t, std::nullptr_t> {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        const types::f77_integer ncnln,
        utility::array1D<double, data_handling::ArgIntent::IntentOUT> &gx,
        types::f77_integer &inform) {
        return;
      }
    };

    void e04st_congrdh(const E04STFT_CONGRD &congrd,
                       types::engine_data &en_data,
                       const types::f77_integer &nvar, const double *x,
                       const types::f77_integer &nnzgd, double *gdx,
                       types::f77_integer &inform, void *iuser, void *ruser) {
      error_handler::ExceptionPointer *ep =
        static_cast<error_handler::ExceptionPointer *>(en_data.wrapptr1);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_x(
        x, nvar);
      utility::array1D<double, data_handling::ArgIntent::IntentINOUT> local_gdx(
        gdx, nnzgd);
      data_handling::CallbackAddresses *callbacks =
        static_cast<data_handling::CallbackAddresses *>(en_data.wrapptr2);

      try {
        if (static_cast<bool>((*callbacks).address[3])) {
          congrd(callbacks, en_data, local_x, local_gdx, inform);
        } else {
          e04styt_(en_data, nvar, x, nnzgd, gdx, inform, iuser, ruser);
        }
      } catch (...) {
        // callback threw an exception
        en_data.hlperr = error_handler::HLPERR_USER_EXCEPTION;
        ep->eptr = std::current_exception();
      }

      if ((x != local_x.data()) && (gdx != local_gdx.data())) {
        // address of an array changed
        en_data.hlperr = error_handler::HLPERR_ARRAY_POINTER_CHANGED;
        return;
      }
    }

    template <typename CONGRD_X, typename CONGRD_GDX, typename CONGRD>
    struct e04st_congrd_cs {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &gdx,
        types::f77_integer &inform) {
        CONGRD &congrd =
          *((typename std::remove_reference<CONGRD>::type *)(*callbacks)
              .address[3]);

        auto local_x = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, CONGRD_X>(x);
        auto local_gdx = data_handling::convert_nag_array_to_user<
          utility::array1D<double, data_handling::ArgIntent::IntentINOUT>,
          data_handling::ArgIntent::IntentINOUT, CONGRD_GDX>(gdx);

        congrd(local_x.get(), local_gdx.get(), inform);
      }
    };

    template <>
    struct e04st_congrd_cs<std::nullptr_t, std::nullptr_t, std::nullptr_t> {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &gdx,
        types::f77_integer &inform) {
        return;
      }
    };

    void e04st_hessh(const E04STFT_HESS &hess, types::engine_data &en_data,
                     const types::f77_integer &nvar, const double *x,
                     const types::f77_integer &ncnln,
                     const types::f77_integer &idf, const double &sigma,
                     const double *lamda, const types::f77_integer &nnzh,
                     double *hx, types::f77_integer &inform, void *iuser,
                     void *ruser) {
      error_handler::ExceptionPointer *ep =
        static_cast<error_handler::ExceptionPointer *>(en_data.wrapptr1);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_x(
        x, nvar);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_lamda(
        lamda, ncnln);
      utility::array1D<double, data_handling::ArgIntent::IntentINOUT> local_hx(
        hx, nnzh);
      data_handling::CallbackAddresses *callbacks =
        static_cast<data_handling::CallbackAddresses *>(en_data.wrapptr2);

      try {
        if (static_cast<bool>((*callbacks).address[4])) {
          hess(callbacks, en_data, local_x, idf, sigma, local_lamda, local_hx,
               inform);
        } else {
          e04stzt_(en_data, nvar, x, ncnln, idf, sigma, lamda, nnzh, hx, inform,
                   iuser, ruser);
        }
      } catch (...) {
        // callback threw an exception
        en_data.hlperr = error_handler::HLPERR_USER_EXCEPTION;
        ep->eptr = std::current_exception();
      }

      if ((x != local_x.data()) && (lamda != local_lamda.data()) &&
          (hx != local_hx.data())) {
        // address of an array changed
        en_data.hlperr = error_handler::HLPERR_ARRAY_POINTER_CHANGED;
        return;
      }
    }

    template <typename HESS_X, typename HESS_LAMDA, typename HESS_HX,
              typename HESS>
    struct e04st_hess_cs {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        const types::f77_integer idf, const double sigma,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN>
          &lamda,
        utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &hx,
        types::f77_integer &inform) {
        HESS &hess =
          *((typename std::remove_reference<HESS>::type *)(*callbacks)
              .address[4]);

        auto local_x = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, HESS_X>(x);
        auto local_lamda = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, HESS_LAMDA>(lamda);
        auto local_hx = data_handling::convert_nag_array_to_user<
          utility::array1D<double, data_handling::ArgIntent::IntentINOUT>,
          data_handling::ArgIntent::IntentINOUT, HESS_HX>(hx);

        hess(local_x.get(), idf, sigma, local_lamda.get(), local_hx.get(),
             inform);
      }
    };

    template <>
    struct e04st_hess_cs<std::nullptr_t, std::nullptr_t, std::nullptr_t,
                         std::nullptr_t> {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        const types::f77_integer idf, const double sigma,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN>
          &lamda,
        utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &hx,
        types::f77_integer &inform) {
        return;
      }
    };

    void e04st_monith(const E04STFT_MONIT &monit, types::engine_data &en_data,
                      const types::f77_integer &nvar, const double *x,
                      const types::f77_integer &nnzu, const double *u,
                      types::f77_integer &inform, const double *rinfo,
                      const double *stats, void *iuser, void *ruser) {
      error_handler::ExceptionPointer *ep =
        static_cast<error_handler::ExceptionPointer *>(en_data.wrapptr1);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_x(
        x, nvar);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_u(
        u, nnzu);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_rinfo(
        rinfo, 100);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_stats(
        stats, 100);
      data_handling::CallbackAddresses *callbacks =
        static_cast<data_handling::CallbackAddresses *>(en_data.wrapptr2);

      try {
        if (static_cast<bool>((*callbacks).address[5])) {
          monit(callbacks, en_data, local_x, local_u, local_rinfo, local_stats);
        } else {
          e04stut_(en_data, nvar, x, nnzu, u, inform, rinfo, stats, iuser,
                   ruser);
        }
      } catch (const error_handler::CallbackEarlyTermination &e) {
        // user threw an early termination exception
        NAG_UNUSED_PARAMETER(e);
        en_data.hlperr = 0;
        inform = -1;
        ep->eptr = std::current_exception();

      } catch (...) {
        // callback threw an exception
        en_data.hlperr = error_handler::HLPERR_USER_EXCEPTION;
        ep->eptr = std::current_exception();
      }

      if ((x != local_x.data()) && (u != local_u.data()) &&
          (rinfo != local_rinfo.data()) && (stats != local_stats.data())) {
        // address of an array changed
        en_data.hlperr = error_handler::HLPERR_ARRAY_POINTER_CHANGED;
        return;
      }
    }

    template <typename MONIT_X, typename MONIT_U, typename MONIT_RINFO,
              typename MONIT_STATS, typename MONIT>
    struct e04st_monit_cs {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &u,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN>
          &rinfo,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN>
          &stats) {
        MONIT &monit =
          *((typename std::remove_reference<MONIT>::type *)(*callbacks)
              .address[5]);

        auto local_x = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, MONIT_X>(x);
        auto local_u = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, MONIT_U>(u);
        auto local_rinfo = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, MONIT_RINFO>(rinfo);
        auto local_stats = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, MONIT_STATS>(stats);

        monit(local_x.get(), local_u.get(), local_rinfo.get(),
              local_stats.get());
      }
    };

    template <>
    struct e04st_monit_cs<std::nullptr_t, std::nullptr_t, std::nullptr_t,
                          std::nullptr_t, std::nullptr_t> {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &u,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN>
          &rinfo,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN>
          &stats) {
        return;
      }
    };

    template <typename COMM, typename OBJFUN, typename OBJGRD, typename CONFUN,
              typename CONGRD, typename HESS, typename MONIT, typename X,
              typename U, typename RINFO, typename STATS>
    void handle_solve_ipopt(COMM &comm, OBJFUN &&objfun, OBJGRD &&objgrd,
                            CONFUN &&confun, CONGRD &&congrd, HESS &&hess,
                            MONIT &&monit, X &&x, U &&u, RINFO &&rinfo,
                            STATS &&stats, opt::OptionalE04ST &opt) {
      opt.fail.prepare("opt::handle_solve_ipopt (e04st)");
      types::engine_data en_data;
      engine_routines::y90haan_(en_data);
      en_data.allocate_workspace = constants::NAG_ED_YES;
      error_handler::ExceptionPointer ep;
      en_data.wrapptr1 = &ep;
      static_assert(std::is_same<COMM, utility::NoneCopyableComm>::value ||
                      std::is_same<COMM, opt::CommE04RA>::value,
                    "Invalid type for comm: must be either "
                    "utility::NoneCopyableComm or opt::CommE04RA");
      if (!(comm.check())) {
        opt.fail.raise_error_comm_invalid("comm");
        if (opt.fail.error_thrown) {
          return;
        }
      }
      data_handling::CallbackAddresses callbacks(6);
      en_data.wrapptr2 = static_cast<void *>(std::addressof(callbacks));
      callbacks.address[0] =
        callback_handling::function_to_void_pointer(objfun);
      callbacks.address[1] =
        callback_handling::function_to_void_pointer(objgrd);
      callbacks.address[2] =
        callback_handling::function_to_void_pointer(confun);
      callbacks.address[3] =
        callback_handling::function_to_void_pointer(congrd);
      callbacks.address[4] = callback_handling::function_to_void_pointer(hess);
      callbacks.address[5] = callback_handling::function_to_void_pointer(monit);
      data_handling::RawData<double, data_handling::ArgIntent::IntentINOUT,
                             typename std::remove_reference<X>::type>
        local_x(x);
      data_handling::RawData<double, data_handling::ArgIntent::IntentINOUT,
                             typename std::remove_reference<U>::type>
        local_u(u);

      void *local_print_rec = static_cast<void *>(&opt.iomanager);
      using local_objfun_x_t = callback_handling::get_argument_type_t<
        0, callback_handling::argument_type_of_t<
             typename std::remove_reference<OBJFUN>::type>>;
      auto local_objfun =
        e04st_objfun_cs<local_objfun_x_t,
                        typename std::remove_reference<OBJFUN>::type>::run;
      using local_objgrd_x_t = callback_handling::get_argument_type_t<
        0, callback_handling::argument_type_of_t<
             typename std::remove_reference<OBJGRD>::type>>;
      using local_objgrd_fdx_t = callback_handling::get_argument_type_t<
        1, callback_handling::argument_type_of_t<
             typename std::remove_reference<OBJGRD>::type>>;
      auto local_objgrd =
        e04st_objgrd_cs<local_objgrd_x_t, local_objgrd_fdx_t,
                        typename std::remove_reference<OBJGRD>::type>::run;
      using local_confun_x_t = callback_handling::get_argument_type_t<
        0, callback_handling::argument_type_of_t<
             typename std::remove_reference<CONFUN>::type>>;
      using local_confun_gx_t = callback_handling::get_argument_type_t<
        2, callback_handling::argument_type_of_t<
             typename std::remove_reference<CONFUN>::type>>;
      auto local_confun =
        e04st_confun_cs<local_confun_x_t, local_confun_gx_t,
                        typename std::remove_reference<CONFUN>::type>::run;
      using local_congrd_x_t = callback_handling::get_argument_type_t<
        0, callback_handling::argument_type_of_t<
             typename std::remove_reference<CONGRD>::type>>;
      using local_congrd_gdx_t = callback_handling::get_argument_type_t<
        1, callback_handling::argument_type_of_t<
             typename std::remove_reference<CONGRD>::type>>;
      auto local_congrd =
        e04st_congrd_cs<local_congrd_x_t, local_congrd_gdx_t,
                        typename std::remove_reference<CONGRD>::type>::run;
      using local_hess_x_t = callback_handling::get_argument_type_t<
        0, callback_handling::argument_type_of_t<
             typename std::remove_reference<HESS>::type>>;
      using local_hess_lamda_t = callback_handling::get_argument_type_t<
        3, callback_handling::argument_type_of_t<
             typename std::remove_reference<HESS>::type>>;
      using local_hess_hx_t = callback_handling::get_argument_type_t<
        4, callback_handling::argument_type_of_t<
             typename std::remove_reference<HESS>::type>>;
      auto local_hess =
        e04st_hess_cs<local_hess_x_t, local_hess_lamda_t, local_hess_hx_t,
                      typename std::remove_reference<HESS>::type>::run;
      using local_monit_x_t = callback_handling::get_argument_type_t<
        0, callback_handling::argument_type_of_t<
             typename std::remove_reference<MONIT>::type>>;
      using local_monit_u_t = callback_handling::get_argument_type_t<
        1, callback_handling::argument_type_of_t<
             typename std::remove_reference<MONIT>::type>>;
      using local_monit_rinfo_t = callback_handling::get_argument_type_t<
        2, callback_handling::argument_type_of_t<
             typename std::remove_reference<MONIT>::type>>;
      using local_monit_stats_t = callback_handling::get_argument_type_t<
        3, callback_handling::argument_type_of_t<
             typename std::remove_reference<MONIT>::type>>;
      auto local_monit =
        e04st_monit_cs<local_monit_x_t, local_monit_u_t, local_monit_rinfo_t,
                       local_monit_stats_t,
                       typename std::remove_reference<MONIT>::type>::run;
      types::f77_integer local_nvar =
        data_handling::get_size(opt.fail, "nvar", local_x, 1);
      if (opt.fail.error_thrown) {
        return;
      }
      types::f77_integer local_nnzu =
        data_handling::get_size(opt.fail, "nnzu", local_u, 1);
      if (!(local_u.data)) {
        local_u.resize(u, local_nnzu);
      }
      data_handling::RawData<double, data_handling::ArgIntent::IntentOUT,
                             typename std::remove_reference<RINFO>::type>
        local_rinfo(rinfo);
      local_rinfo.resize(rinfo, static_cast<types::f77_integer>(100));
      data_handling::RawData<double, data_handling::ArgIntent::IntentOUT,
                             typename std::remove_reference<STATS>::type>
        local_stats(stats);
      local_stats.resize(stats, static_cast<types::f77_integer>(100));
      void *local_iuser = nullptr;
      void *local_ruser = nullptr;

      local_stats.check(opt.fail, "stats", true,
                        static_cast<types::f77_integer>(100));
      if (opt.fail.error_thrown) {
        return;
      }
      local_rinfo.check(opt.fail, "rinfo", true,
                        static_cast<types::f77_integer>(100));
      if (opt.fail.error_thrown) {
        return;
      }
      local_u.check(opt.fail, "u", false, local_nnzu);
      if (opt.fail.error_thrown) {
        return;
      }
      local_x.check(opt.fail, "x", true, local_nvar);
      if (opt.fail.error_thrown) {
        return;
      }

      e04stft_(en_data, local_print_rec, utility::print_rech, &comm.handle,
               local_objfun, e04st_objfunh, local_objgrd, e04st_objgrdh,
               local_confun, e04st_confunh, local_congrd, e04st_congrdh,
               local_hess, e04st_hessh, local_monit, e04st_monith, local_nvar,
               local_x.data, local_nnzu, local_u.data, local_rinfo.data,
               local_stats.data, local_iuser, local_ruser, opt.fail.errbuf,
               opt.fail.errorid, opt.fail.errbuf_length);

      if (!(opt.fail.initial_error_handler(en_data))) {
        if (opt.fail.ierr == -199 && opt.fail.ifmt == 100) {
          opt.fail.set_errorid(-199, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "opt::handle_solve_ipopt is not available "
                                     "in this implementation.");
        } else if (opt.fail.ierr == 1 && opt.fail.ifmt == 100) {
          opt.fail.set_errorid(1, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "comm.handle has not been initialized.");
        } else if (opt.fail.ierr == 1 && opt.fail.ifmt == 101) {
          opt.fail.set_errorid(1, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "comm.handle does not belong to the NAG "
                                     "optimization modelling suite,");
          opt.fail.append_msg(false, "has not been initialized properly or is "
                                     "corrupted.");
        } else if (opt.fail.ierr == 1 && opt.fail.ifmt == 102) {
          opt.fail.set_errorid(1, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "comm.handle has not been initialized "
                                     "properly or is corrupted.");
        } else if (opt.fail.ierr == 2 && opt.fail.ifmt == 201) {
          opt.fail.set_errorid(2, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "The problem is already being solved.");
        } else if (opt.fail.ierr == 2 && opt.fail.ifmt == 202) {
          opt.fail.set_errorid(2, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "This solver does not support the model "
                                     "defined in the handle.");
        } else if (opt.fail.ierr == 4 && opt.fail.ifmt == 401) {
          opt.fail.set_errorid(4, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry, nvar = ", 1, ",");
          opt.fail.append_msg(true, "expected value = ", 2, ".");
          opt.fail.append_msg(false, "Constraint: nvar must match the current "
                                     "number of variables");
          opt.fail.append_msg(false, "of the model in the comm.handle.");
        } else if (opt.fail.ierr == 5 && opt.fail.ifmt == 501) {
          opt.fail.set_errorid(5, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(true, "On entry, nnzu = ", 1, ".");
          opt.fail.append_msg(false, "Constraint: nnzu = ", 2, " or 0.");
        } else if (opt.fail.ierr == 5 && opt.fail.ifmt == 502) {
          opt.fail.set_errorid(5, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(true, "On entry, nnzu = ", 1, ".");
          opt.fail.append_msg(false, "Constraint: no constraints present, so "
                                     "nnzu must be 0.");
        } else if (opt.fail.ierr == 6 && opt.fail.ifmt == 600) {
          opt.fail.set_errorid(6, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry, a nonlinear objective function "
                                     "has been defined");
          opt.fail.append_msg(false, "but no objective Hessian sparsity "
                                     "structure has been defined");
          opt.fail.append_msg(false, "through opt::handle_set_nlnhess.");
        } else if (opt.fail.ierr == 6 && opt.fail.ifmt == 601) {
          opt.fail.set_errorid(6, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry, a nonlinear constraint "
                                     "function has been defined");
          opt.fail.append_msg(false, "but no constraint Hessian sparsity "
                                     "structure has been defined");
          opt.fail.append_msg(false,
                              "through opt::handle_set_nlnhess, for constraint "
                              "number ",
                              1, ".");
        } else if (opt.fail.ierr == 7 && opt.fail.ifmt == 702) {
          opt.fail.set_errorid(7, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "Either change the option \"Hessian "
                                     "Mode\" or");
          opt.fail.append_msg(false, "provide a proper hess function.");
        } else if (opt.fail.ierr == 7 && opt.fail.ifmt == 703) {
          opt.fail.set_errorid(7, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "Please provide a proper objfun "
                                     "function.");
        } else if (opt.fail.ierr == 7 && opt.fail.ifmt == 704) {
          opt.fail.set_errorid(7, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "Please provide a proper objgrd "
                                     "function.");
        } else if (opt.fail.ierr == 7 && opt.fail.ifmt == 705) {
          opt.fail.set_errorid(7, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "Please provide a proper confun "
                                     "function.");
        } else if (opt.fail.ierr == 7 && opt.fail.ifmt == 706) {
          opt.fail.set_errorid(7, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "Please provide a proper congrd "
                                     "function.");
        } else if (opt.fail.ierr == 20) {
          opt.fail.set_errorid(20, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "User requested termination during a "
                                     "monitoring step.");
          opt.fail.append_exception_msg(en_data);
        } else if (opt.fail.ierr == 22 && opt.fail.ifmt == 2201) {
          opt.fail.set_errorid(22, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "Maximum number of iterations exceeded.");
        } else if (opt.fail.ierr == 23 && opt.fail.ifmt == 2301) {
          opt.fail.set_errorid(23, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "The solver terminated after failure in "
                                     "the restoration phase.");
        } else if (opt.fail.ierr == 23 && opt.fail.ifmt == 2302) {
          opt.fail.set_errorid(23, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "The solver terminated after an error in "
                                     "the step computation.");
        } else if (opt.fail.ierr == 23 && opt.fail.ifmt == 2303) {
          opt.fail.set_errorid(23, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "The solver terminated after the maximum "
                                     "time allowed was exceeded.");
        } else if (opt.fail.ierr == 23 && opt.fail.ifmt == 2304) {
          opt.fail.set_errorid(23, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "The solver terminated with not enough "
                                     "degrees of freedom.");
        } else if (opt.fail.ierr == 23 && opt.fail.ifmt == 2305) {
          opt.fail.set_errorid(23, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "The solver terminated due to an invalid "
                                     "problem definition.");
        } else if (opt.fail.ierr == 23 && opt.fail.ifmt == 2306) {
          opt.fail.set_errorid(23, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "The solver terminated due to an invalid "
                                     "option.");
        } else if (opt.fail.ierr == 24 && opt.fail.ifmt == 2401) {
          opt.fail.set_errorid(24, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "The solver terminated after the search "
                                     "direction became too small.");
        } else if (opt.fail.ierr == 25 && opt.fail.ifmt == 2501) {
          opt.fail.set_errorid(25, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "Invalid number detected in user "
                                     "function.");
        } else if (opt.fail.ierr == 50) {
          opt.fail.set_errorid(50, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "The solver reports NLP solved to "
                                     "acceptable level.");
        } else if (opt.fail.ierr == 51) {
          opt.fail.set_errorid(51, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "The solver detected an infeasible "
                                     "problem.");
        } else if (opt.fail.ierr == 54) {
          opt.fail.set_errorid(54, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "The solver terminated due to diverging "
                                     "iterates.");
        } else {
          opt.fail.set_unexpected_error();
        }
        opt.fail.throw_error();
      }
      if (opt.fail.error_thrown) {
        return;
      }

      local_x.copy_back(x);
      local_u.copy_back(u);
      local_rinfo.copy_back(rinfo);
      local_stats.copy_back(stats);
      opt.fail.throw_warning();
    }

    // alt-1
    template <typename COMM, typename OBJFUN, typename OBJGRD, typename CONFUN,
              typename CONGRD, typename HESS, typename MONIT, typename X,
              typename U, typename RINFO, typename STATS>
    void handle_solve_ipopt(COMM &comm, OBJFUN &&objfun, OBJGRD &&objgrd,
                            CONFUN &&confun, CONGRD &&congrd, HESS &&hess,
                            MONIT &&monit, X &&x, U &&u, RINFO &&rinfo,
                            STATS &&stats) {
      opt::OptionalE04ST local_opt;

      handle_solve_ipopt(comm, objfun, objgrd, confun, congrd, hess, monit, x,
                         u, rinfo, stats, local_opt);
    }
  }
}
#define e04st opt::handle_solve_ipopt
#endif
