// Header for nagcpp::opt::nlp1_init (e04wb)

// Copyright 2022, Numerical Algorithms Group Ltd, Oxford, UK.
// Generated by cpp-ft-wrapper.xsl
// Version 28.5.0.0
#ifndef NAGCPP_E04WB_HPP
#define NAGCPP_E04WB_HPP

#include "utility/nagcpp_consts.hpp"
#include "utility/nagcpp_data_handling.hpp"
#include "utility/nagcpp_engine_routines.hpp"
#include "utility/nagcpp_engine_types.hpp"
#include "utility/nagcpp_error_handler.hpp"
#include "utility/nagcpp_utility_comm.hpp"
#include "utility/nagcpp_utility_functions.hpp"
#include "utility/nagcpp_utility_optional.hpp"

namespace nagcpp {
  namespace opt {
    // nlp1_init (e04wb)
    // Initialization function for opt::uncon_conjgrd_comp (e04dg), opt::lp_solve
    // (e04mf), opt::lsq_lincon_solve (e04nc), opt::qp_dense_solve (e04nf),
    // opt::qpconvex1_sparse_solve (e04nk), opt::nlp1_solve (e04uc),
    // opt::nlp1_rcomm (e04uf) and opt::lsq_gencon_deriv (e04us).
    // opt::nlp1_init (e04wb) is used to initialize functions
    // opt::uncon_conjgrd_comp (e04dg), opt::lp_solve (e04mf),
    // opt::lsq_lincon_solve (e04nc), opt::qp_dense_solve (e04nf),
    // opt::qpconvex1_sparse_solve (e04nk), opt::nlp1_solve (e04uc),
    // opt::nlp1_rcomm (e04uf), opt::nlp1_sparse_solve (e04ug) and
    // opt::lsq_gencon_deriv (e04us).

    // parameters:
    //   rname: std::string, scalar
    //     The name of the function to be initialized
    //   comm: opt::CommE04WB, scalar
    //     Communication structure.
    //   opt: opt::OptionalE04WB
    //     Optional parameter container, derived from utility::Optional.
    //     contains:
    //       fail: error_handler::ErrorHandler

    // error_handler::ErrorException
    //   (errorid 1)
    //     On entry, rname = "<value>" was not a valid function name.
    //   (errorid -99)
    //     An unexpected error has been triggered by this routine.
    //   (errorid -399)
    //     Your licence key may have expired or may not have been installed correctly.
    //   (errorid -999)
    //     Dynamic memory allocation failed.

    extern "C" {
#if defined(_WIN32) && defined(USE_STDCALL)
#define e04wbft_(en_data, rname, cwsav, lcwsav, lwsav, llwsav, iwsav, liwsav, \
                 rwsav, lrwsav, errbuf, ifail, rname_length, cwsav_length,    \
                 errbuf_length)                                               \
  E04WBFT(en_data, rname, rname_length, cwsav, cwsav_length, lcwsav, lwsav,   \
          llwsav, iwsav, liwsav, rwsav, lrwsav, errbuf, errbuf_length, ifail)
#elif defined(_WIN32) || defined(_WIN64)
#define e04wbft_ E04WBFT
#else
#define E04WBFT e04wbft_
#endif
    extern void NAG_CALL
      E04WBFT(types::engine_data &en_data,
              const char *rname NAG_STDCALL_LEN(rname_length),
              char cwsav[] NAG_STDCALL_LEN(cwsav_length),
              const types::f77_integer &lcwsav, types::f77_logical lwsav[],
              const types::f77_integer &llwsav, types::f77_integer iwsav[],
              const types::f77_integer &liwsav, double rwsav[],
              const types::f77_integer &lrwsav,
              char *errbuf NAG_STDCALL_LEN(errbuf_length),
              types::f77_integer &ifail NAG_NSTDCALL_LEN(rname_length)
                NAG_NSTDCALL_LEN(cwsav_length) NAG_NSTDCALL_LEN(errbuf_length));
    }

    class CommE04WB;

    class OptionalE04WB : public utility::Optional {
    public:
      OptionalE04WB() : Optional() {}
      template <typename COMM>
      friend void nlp1_init(const std::string rname, COMM &comm,
                            opt::OptionalE04WB &opt);
    };

    template <typename COMM>
    void nlp1_init(const std::string rname, COMM &comm,
                   opt::OptionalE04WB &opt) {
      opt.fail.prepare("opt::nlp1_init (e04wb)");
      types::engine_data en_data;
      engine_routines::y90haan_(en_data);
      en_data.allocate_workspace = constants::NAG_ED_YES;
      static_assert(std::is_same<COMM, utility::CopyableComm>::value ||
                      std::is_same<COMM, opt::CommE04WB>::value,
                    "Invalid type for comm: must be either "
                    "utility::CopyableComm or opt::CommE04WB");

      data_handling::StringRawData<data_handling::ArgIntent::IntentIN>
        local_rname(rname);
      types::f77_integer local_cwsav_dim1;
      if (utility::rname_eq(rname, "e04uf") ||
          utility::rname_eq(rname, "nlp1_rcomm")) {
        local_cwsav_dim1 = 5;
      } else {
        local_cwsav_dim1 = 1;
      }
      types::f77_integer local_lwsav_dim1;
      if (utility::rname_eq(rname, "e04nk") ||
          utility::rname_eq(rname, "qpconvex1_sparse_solve")) {
        local_lwsav_dim1 = 20;
      } else if (utility::rname_eq(rname, "e04ug") ||
                 utility::rname_eq(rname, "nlp1_sparse_solve")) {
        local_lwsav_dim1 = 20;
      } else {
        local_lwsav_dim1 = 120;
      }
      types::f77_integer local_iwsav_dim1;
      if (utility::rname_eq(rname, "e04nk") ||
          utility::rname_eq(rname, "qpconvex1_sparse_solve")) {
        local_iwsav_dim1 = 380;
      } else if (utility::rname_eq(rname, "e04ug") ||
                 utility::rname_eq(rname, "nlp1_sparse_solve")) {
        local_iwsav_dim1 = 550;
      } else {
        local_iwsav_dim1 = 610;
      }
      types::f77_integer local_rwsav_dim1;
      if (utility::rname_eq(rname, "e04nk") ||
          utility::rname_eq(rname, "qpconvex1_sparse_solve")) {
        local_rwsav_dim1 = 285;
      } else if (utility::rname_eq(rname, "e04ug") ||
                 utility::rname_eq(rname, "nlp1_sparse_solve")) {
        local_rwsav_dim1 = 550;
      } else {
        local_rwsav_dim1 = 475;
      }
      comm.allocate(opt.fail, local_rwsav_dim1, local_iwsav_dim1,
                    local_cwsav_dim1, local_lwsav_dim1);
      if (opt.fail.error_thrown) {
        return;
      }

      e04wbft_(en_data, local_rname.data, comm.ccomm, comm.lccomm, comm.lcomm,
               comm.llcomm, comm.icomm, comm.licomm, comm.rcomm, comm.lrcomm,
               opt.fail.errbuf, opt.fail.errorid, local_rname.string_length,
               comm.ccomm_length, opt.fail.errbuf_length);

      if (!(opt.fail.initial_error_handler(en_data))) {
        if (opt.fail.ierr == 1 && opt.fail.ifmt == 99999) {
          opt.fail.set_errorid(1, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry, rname = \"" + rname +
                                       "\" was not a valid function name.");
        } else {
          opt.fail.set_unexpected_error();
        }
        opt.fail.throw_error();
      }
      if (opt.fail.error_thrown) {
        return;
      }

      comm.initialized = true;
      opt.fail.throw_warning();
    }

    // alt-1
    template <typename COMM>
    void nlp1_init(const std::string rname, COMM &comm) {
      opt::OptionalE04WB local_opt;

      nlp1_init(rname, comm, local_opt);
    }
  }
}
#define e04wb opt::nlp1_init
#endif
