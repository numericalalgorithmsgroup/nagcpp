// Header for the communication class for routines who need to be initialized
// via a call to nagcpp::opt::handle_init (e04ra)

// Copyright 2022, Numerical Algorithms Group Ltd, Oxford, UK.
// Generated by cpp-ft-wrapper.xsl
// Version 28.5.0.0
#ifndef NAGCPP_COMME04RA
#define NAGCPP_COMME04RA

#include "e04/nagcpp_e04ra.hpp"
#include "e04/nagcpp_e04rz.hpp"
#include "e04/nagcpp_e04zm.hpp"
#include "e04/nagcpp_e04zn.hpp"
#include "utility/nagcpp_utility_comm.hpp"
#include "utility/nagcpp_utility_functions.hpp"

namespace nagcpp {
  namespace opt {
    class CommE04RA : public utility::NoneCopyableComm {
    public:
      CommE04RA(void *handle_) : NoneCopyableComm(handle_) {}
      CommE04RA(const types::f77_integer nvar, opt::OptionalE04RA &opt)
        : NoneCopyableComm() {
        handle_init((*this), nvar, opt);
      }
      CommE04RA(const types::f77_integer nvar) : NoneCopyableComm() {
        handle_init((*this), nvar);
      }
      ~CommE04RA() {
        if (initialized) {
          try {
            handle_free((*this));
            initialized = false;
          } catch (...) {
            // we should never get here, and if we do
            // there is nothing the user can do about it
            // it will just mean that the handle was not set
            // up and so there is nothing to free
          }
        }
      }
      CommE04RA &set(const std::string optstr, opt::OptionalE04ZM &opt) {
        handle_opt_set((*this), optstr, opt);
        return (*this);
      }
      CommE04RA &set(const std::string optstr) {
        handle_opt_set((*this), optstr);
        return (*this);
      }
      void get(const std::string optstr, types::f77_integer &ivalue,
               double &rvalue, std::string &cvalue, types::f77_integer &optype,
               opt::OptionalE04ZN &opt) {
        handle_opt_get((*this), optstr, ivalue, rvalue, cvalue, optype, opt);
      }
      void get(const std::string optstr, types::f77_integer &ivalue,
               double &rvalue, std::string &cvalue,
               types::f77_integer &optype) {
        handle_opt_get((*this), optstr, ivalue, rvalue, cvalue, optype);
      }

      // DFLS Small Residuals Tol:
      //   Default = epsilon^0.75
      //   This option defines the tolerance on the value of the residuals
      CommE04RA &DFLSSmallResidualsTol(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFLS Small Residuals Tol", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFLSSmallResidualsTol(double value) {
        opt::OptionalE04ZM local_opt;
        return DFLSSmallResidualsTol(value, local_opt);
      }
      double get_DFLSSmallResidualsTol(void) {
        std::string local_optstr = "DFLS Small Residuals Tol";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // DFNO Detect Unbounded:
      //   Default = "YES"
      //   The solver can try to detect whether the problem is unbounded
      CommE04RA &DFNODetectUnbounded(std::string value,
                                     opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFNO Detect Unbounded", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFNODetectUnbounded(std::string value) {
        opt::OptionalE04ZM local_opt;
        return DFNODetectUnbounded(value, local_opt);
      }
      std::string get_DFNODetectUnbounded(void) {
        std::string local_optstr = "DFNO Detect Unbounded";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // DFNO Objective Limit:
      //   Default = - infinity
      //   This option sets an additional convergence criterion
      CommE04RA &DFNOObjectiveLimit(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFNO Objective Limit", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFNOObjectiveLimit(double value) {
        opt::OptionalE04ZM local_opt;
        return DFNOObjectiveLimit(value, local_opt);
      }
      double get_DFNOObjectiveLimit(void) {
        std::string local_optstr = "DFNO Objective Limit";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // DFO Initial Interp Points:
      //   Default = "Coordinate"
      //   Determines how the initial interpolation points are chosen
      CommE04RA &DFOInitialInterpPoints(std::string value,
                                        opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Initial Interp Points", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOInitialInterpPoints(std::string value) {
        opt::OptionalE04ZM local_opt;
        return DFOInitialInterpPoints(value, local_opt);
      }
      std::string get_DFOInitialInterpPoints(void) {
        std::string local_optstr = "DFO Initial Interp Points";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // DFO Max Objective Calls:
      //   Default = 500
      //   A limit on the number of objective function evaluations the solver is
      //   allowed to compute
      CommE04RA &DFOMaxObjectiveCalls(types::f77_integer value,
                                      opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Max Objective Calls", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOMaxObjectiveCalls(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFOMaxObjectiveCalls(value, local_opt);
      }
      types::f77_integer get_DFOMaxObjectiveCalls(void) {
        std::string local_optstr = "DFO Max Objective Calls";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Max Soft Restarts:
      //   Default = 5
      //   The maximum total number of soft restarts that can be performed if the
      //   objective function is declared as noisy ("DFO Noisy Problem" = "YES")
      CommE04RA &DFOMaxSoftRestarts(types::f77_integer value,
                                    opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Max Soft Restarts", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOMaxSoftRestarts(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFOMaxSoftRestarts(value, local_opt);
      }
      types::f77_integer get_DFOMaxSoftRestarts(void) {
        std::string local_optstr = "DFO Max Soft Restarts";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Max Unsucc Soft Restarts:
      //   Default = 3
      //   The maximum number of consecutive unsuccessful soft restarts that can be
      //   performed if the objective function is declared as noisy ("DFO Noisy
      //   Problem" = "YES")
      CommE04RA &DFOMaxUnsuccSoftRestarts(types::f77_integer value,
                                          opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Max Unsucc Soft Restarts", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOMaxUnsuccSoftRestarts(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFOMaxUnsuccSoftRestarts(value, local_opt);
      }
      types::f77_integer get_DFOMaxUnsuccSoftRestarts(void) {
        std::string local_optstr = "DFO Max Unsucc Soft Restarts";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Maximum Slow Steps:
      //   Default = 20
      //   If "DFO Maximum Slow Steps" > 0, this parameter defines the maximum number
      //   of consecutive slow iterations n_slow allowed
      CommE04RA &DFOMaximumSlowSteps(types::f77_integer value,
                                     opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Maximum Slow Steps", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOMaximumSlowSteps(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFOMaximumSlowSteps(value, local_opt);
      }
      types::f77_integer get_DFOMaximumSlowSteps(void) {
        std::string local_optstr = "DFO Maximum Slow Steps";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Monitor Frequency:
      //   Default = 0
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &DFOMonitorFrequency(types::f77_integer value,
                                     opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Monitor Frequency", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOMonitorFrequency(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFOMonitorFrequency(value, local_opt);
      }
      types::f77_integer get_DFOMonitorFrequency(void) {
        std::string local_optstr = "DFO Monitor Frequency";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Noise Level:
      //   Default = 0.0
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &DFONoiseLevel(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Noise Level", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFONoiseLevel(double value) {
        opt::OptionalE04ZM local_opt;
        return DFONoiseLevel(value, local_opt);
      }
      double get_DFONoiseLevel(void) {
        std::string local_optstr = "DFO Noise Level";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // DFO Noisy Problem:
      //   Default = "NO"
      //   Indicates if the function evaluations provided to the solver are noisy
      CommE04RA &DFONoisyProblem(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Noisy Problem", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFONoisyProblem(std::string value) {
        opt::OptionalE04ZM local_opt;
        return DFONoisyProblem(value, local_opt);
      }
      std::string get_DFONoisyProblem(void) {
        std::string local_optstr = "DFO Noisy Problem";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // DFO Number Initial Points:
      //   Default = 0
      //   The initial number of interpolation points in Y_0 (1) used to build the
      //   linear models of the residuals
      CommE04RA &DFONumberInitialPoints(types::f77_integer value,
                                        opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Number Initial Points", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFONumberInitialPoints(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFONumberInitialPoints(value, local_opt);
      }
      types::f77_integer get_DFONumberInitialPoints(void) {
        std::string local_optstr = "DFO Number Initial Points";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Number Interp Points:
      //   Default = 0
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &DFONumberInterpPoints(types::f77_integer value,
                                       opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Number Interp Points", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFONumberInterpPoints(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFONumberInterpPoints(value, local_opt);
      }
      types::f77_integer get_DFONumberInterpPoints(void) {
        std::string local_optstr = "DFO Number Interp Points";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Number Soft Restarts Pts:
      //   Default = 3
      //   The number of interpolation points that are replaced during a soft restart
      CommE04RA &DFONumberSoftRestartsPts(types::f77_integer value,
                                          opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Number Soft Restarts Pts", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFONumberSoftRestartsPts(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFONumberSoftRestartsPts(value, local_opt);
      }
      types::f77_integer get_DFONumberSoftRestartsPts(void) {
        std::string local_optstr = "DFO Number Soft Restarts Pts";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Print Frequency:
      //   Default = 1
      //   If "DFO Print Frequency" > 0, the solver prints the iteration log to the
      //   appropriate units at the end of every ith step
      CommE04RA &DFOPrintFrequency(types::f77_integer value,
                                   opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Print Frequency", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOPrintFrequency(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFOPrintFrequency(value, local_opt);
      }
      types::f77_integer get_DFOPrintFrequency(void) {
        std::string local_optstr = "DFO Print Frequency";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Random Seed:
      //   Default = -1
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &DFORandomSeed(types::f77_integer value,
                               opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Random Seed", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFORandomSeed(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return DFORandomSeed(value, local_opt);
      }
      types::f77_integer get_DFORandomSeed(void) {
        std::string local_optstr = "DFO Random Seed";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // DFO Starting Trust Region:
      //   Default = 0.1
      //   rho_beg, the initial trust region radius
      CommE04RA &DFOStartingTrustRegion(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Starting Trust Region", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOStartingTrustRegion(double value) {
        opt::OptionalE04ZM local_opt;
        return DFOStartingTrustRegion(value, local_opt);
      }
      double get_DFOStartingTrustRegion(void) {
        std::string local_optstr = "DFO Starting Trust Region";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // DFO Trust Region Slow Tol:
      //   Default = epsilon^0.25
      //   The minimal acceptable trust region radius for the solution to be declared
      //   as acceptable
      CommE04RA &DFOTrustRegionSlowTol(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Trust Region Slow Tol", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOTrustRegionSlowTol(double value) {
        opt::OptionalE04ZM local_opt;
        return DFOTrustRegionSlowTol(value, local_opt);
      }
      double get_DFOTrustRegionSlowTol(void) {
        std::string local_optstr = "DFO Trust Region Slow Tol";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // DFO Trust Region Tolerance:
      //   Default = epsilon^0.37
      //   rho_end, the requested trust region radius
      CommE04RA &DFOTrustRegionTolerance(double value,
                                         opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DFO Trust Region Tolerance", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DFOTrustRegionTolerance(double value) {
        opt::OptionalE04ZM local_opt;
        return DFOTrustRegionTolerance(value, local_opt);
      }
      double get_DFOTrustRegionTolerance(void) {
        std::string local_optstr = "DFO Trust Region Tolerance";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // DIMACS Measures:
      //   Default = "CHECK"
      //   If the problem is a linear semidefinite programming problem, this parameter
      //   specifies if DIMACS error measures (see Stopping Criteria) should be
      //   computed and/or checked
      CommE04RA &DIMACSMeasures(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("DIMACS Measures", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &DIMACSMeasures(std::string value) {
        opt::OptionalE04ZM local_opt;
        return DIMACSMeasures(value, local_opt);
      }
      std::string get_DIMACSMeasures(void) {
        std::string local_optstr = "DIMACS Measures";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Defaults:
      //   This special keyword may be used to reset all options to their default
      //   values
      CommE04RA &Defaults(opt::OptionalE04ZM &opt) {
        std::string local_optstr = "Defaults";
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &Defaults(void) {
        opt::OptionalE04ZM local_opt;
        return Defaults(local_opt);
      }

      // FOAS Estimate Derivatives:
      //   Default = "NO"
      //   This option indicates whether to check for and estimate missing entries of
      //   the user-supplied gradient vector
      CommE04RA &FOASEstimateDerivatives(std::string value,
                                         opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Estimate Derivatives", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASEstimateDerivatives(std::string value) {
        opt::OptionalE04ZM local_opt;
        return FOASEstimateDerivatives(value, local_opt);
      }
      std::string get_FOASEstimateDerivatives(void) {
        std::string local_optstr = "FOAS Estimate Derivatives";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // FOAS Finite Diff Interval:
      //   Default = sqrt(epsilon)
      //   Specifies the relative perturbation size used to estimate a derivative
      //   using the forward (or backward) finite-difference method
      CommE04RA &FOASFiniteDiffInterval(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Finite Diff Interval", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASFiniteDiffInterval(double value) {
        opt::OptionalE04ZM local_opt;
        return FOASFiniteDiffInterval(value, local_opt);
      }
      double get_FOASFiniteDiffInterval(void) {
        std::string local_optstr = "FOAS Finite Diff Interval";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // FOAS Iteration Limit:
      //   Default = 10^7
      //   This parameter sets the maximum number of iterations to be performed by
      //   opt::handle_solve_bounds_foas (e04kf)
      CommE04RA &FOASIterationLimit(types::f77_integer value,
                                    opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Iteration Limit", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASIterationLimit(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return FOASIterationLimit(value, local_opt);
      }
      types::f77_integer get_FOASIterationLimit(void) {
        std::string local_optstr = "FOAS Iteration Limit";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // FOAS Memory:
      //   Default = 11
      //   This parameter specifies the maximum number of memory vectors to use in the
      //   LCG solver
      CommE04RA &FOASMemory(types::f77_integer value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("FOAS Memory", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASMemory(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return FOASMemory(value, local_opt);
      }
      types::f77_integer get_FOASMemory(void) {
        std::string local_optstr = "FOAS Memory";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // FOAS Monitor Frequency:
      //   Default = 0
      //   This parameter specifies the frequency on which to call the monitor
      //   function monit
      CommE04RA &FOASMonitorFrequency(types::f77_integer value,
                                      opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Monitor Frequency", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASMonitorFrequency(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return FOASMonitorFrequency(value, local_opt);
      }
      types::f77_integer get_FOASMonitorFrequency(void) {
        std::string local_optstr = "FOAS Monitor Frequency";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // FOAS Print Frequency:
      //   Default = "1"
      //   This parameter specifies the frequency with which to print information
      //   regarding each iteration to "Print File" and/or "Monitoring File"
      CommE04RA &FOASPrintFrequency(types::f77_integer value,
                                    opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Print Frequency", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASPrintFrequency(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return FOASPrintFrequency(value, local_opt);
      }
      types::f77_integer get_FOASPrintFrequency(void) {
        std::string local_optstr = "FOAS Print Frequency";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // FOAS Progress Tolerance:
      //   Default = epsilon^(3/4)
      //   Specifies the tolerance for epsilon_prog (see [equation]) for which the
      //   function characterises a poor rate of progress given that it deems to be
      //   far from a solution
      CommE04RA &FOASProgressTolerance(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Progress Tolerance", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASProgressTolerance(double value) {
        opt::OptionalE04ZM local_opt;
        return FOASProgressTolerance(value, local_opt);
      }
      double get_FOASProgressTolerance(void) {
        std::string local_optstr = "FOAS Progress Tolerance";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // FOAS Rel Stop Tolerance:
      //   Default = epsilon^(3/4)
      //   This parameter sets the value of epsilon_rel which specifies the relative
      //   tolerance for the convergence measures in the stopping criteria, see
      //   [equation] and [equation] in Stopping Criteria
      CommE04RA &FOASRelStopTolerance(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Rel Stop Tolerance", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASRelStopTolerance(double value) {
        opt::OptionalE04ZM local_opt;
        return FOASRelStopTolerance(value, local_opt);
      }
      double get_FOASRelStopTolerance(void) {
        std::string local_optstr = "FOAS Rel Stop Tolerance";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // FOAS Restart Factor:
      //   Default = 6.0
      //   This factor specifies the frequency nvar*"FOAS Restart Factor" with which
      //   the CG/LCG directions are replaced by the steepest descent direction (d_k =
      //   -g_k)
      CommE04RA &FOASRestartFactor(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Restart Factor", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASRestartFactor(double value) {
        opt::OptionalE04ZM local_opt;
        return FOASRestartFactor(value, local_opt);
      }
      double get_FOASRestartFactor(void) {
        std::string local_optstr = "FOAS Restart Factor";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // FOAS Slow Tolerance:
      //   Default = epsilon^(1/8)
      //   Specifies the tolerance for epsilon_slow (see [equation]) for which the
      //   function characterises a slow rate of convergence
      CommE04RA &FOASSlowTolerance(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Slow Tolerance", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASSlowTolerance(double value) {
        opt::OptionalE04ZM local_opt;
        return FOASSlowTolerance(value, local_opt);
      }
      double get_FOASSlowTolerance(void) {
        std::string local_optstr = "FOAS Slow Tolerance";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // FOAS Stop Tolerance:
      //   Default = max(10^-6,sqrt(epsilon))
      //   This parameter sets the value of epsilon_tol which specifies the tolerance
      //   for the convergence measures in the stopping criteria, see [equation] and
      //   [equation] in Stopping Criteria
      CommE04RA &FOASStopTolerance(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Stop Tolerance", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASStopTolerance(double value) {
        opt::OptionalE04ZM local_opt;
        return FOASStopTolerance(value, local_opt);
      }
      double get_FOASStopTolerance(void) {
        std::string local_optstr = "FOAS Stop Tolerance";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // FOAS Tolerance Norm:
      //   Default = "INFINITY"
      //   This parameter specifies the norm used to measure some stopping metrics,
      //   such as optimality tolerances (see Stopping Criteria)
      CommE04RA &FOASToleranceNorm(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("FOAS Tolerance Norm", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &FOASToleranceNorm(std::string value) {
        opt::OptionalE04ZM local_opt;
        return FOASToleranceNorm(value, local_opt);
      }
      std::string get_FOASToleranceNorm(void) {
        std::string local_optstr = "FOAS Tolerance Norm";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Hessian Density:
      //   Default = "AUTO"
      //   This option guides the solver on how the Hessian matrix of augmented
      //   Lagrangian F(x,u,v,U,p,P) should be built
      CommE04RA &HessianDensity(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Hessian Density", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &HessianDensity(std::string value) {
        opt::OptionalE04ZM local_opt;
        return HessianDensity(value, local_opt);
      }
      std::string get_HessianDensity(void) {
        std::string local_optstr = "Hessian Density";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Hessian Mode:
      //   Default = "AUTO"
      //   This parameter specifies whether the Hessian will be user-supplied (in hx)
      //   or approximated by opt::handle_solve_ipopt (e04st) using a limited-memory
      //   quasi-Newton L-BFGS method
      CommE04RA &HessianMode(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Hessian Mode", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &HessianMode(std::string value) {
        opt::OptionalE04ZM local_opt;
        return HessianMode(value, local_opt);
      }
      std::string get_HessianMode(void) {
        std::string local_optstr = "Hessian Mode";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Infinite Bound Size:
      //   Default = 10^20
      //   This defines the "infinite" bound bigbnd in the definition of the problem
      //   constraints
      CommE04RA &InfiniteBoundSize(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Infinite Bound Size", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InfiniteBoundSize(double value) {
        opt::OptionalE04ZM local_opt;
        return InfiniteBoundSize(value, local_opt);
      }
      double get_InfiniteBoundSize(void) {
        std::string local_optstr = "Infinite Bound Size";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Init Value P:
      //   Default = 1.0
      //   This parameter defines the value p^0, the initial penalty option for
      //   (standard) inequalities
      CommE04RA &InitValueP(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Init Value P", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InitValueP(double value) {
        opt::OptionalE04ZM local_opt;
        return InitValueP(value, local_opt);
      }
      double get_InitValueP(void) {
        std::string local_optstr = "Init Value P";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Init Value Pmat:
      //   Default = 1.0
      //   The value of this option suggests P^0, the initial penalty option for
      //   matrix inequalities
      CommE04RA &InitValuePmat(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Init Value Pmat", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InitValuePmat(double value) {
        opt::OptionalE04ZM local_opt;
        return InitValuePmat(value, local_opt);
      }
      double get_InitValuePmat(void) {
        std::string local_optstr = "Init Value Pmat";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Initial P:
      //   Default = "AUTOMATIC"
      //   This option defines the choice of the penalty options p^0, P^0, see
      //   Algorithm 1
      CommE04RA &InitialP(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Initial P", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InitialP(std::string value) {
        opt::OptionalE04ZM local_opt;
        return InitialP(value, local_opt);
      }
      std::string get_InitialP(void) {
        std::string local_optstr = "Initial P";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Initial U:
      //   Default = "AUTOMATIC"
      //   This parameter guides the solver on which initial Lagrangian multipliers
      //   are to be used
      CommE04RA &InitialU(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Initial U", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InitialU(std::string value) {
        opt::OptionalE04ZM local_opt;
        return InitialU(value, local_opt);
      }
      std::string get_InitialU(void) {
        std::string local_optstr = "Initial U";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Initial Value Ubox:
      //   Default = 1.0
      //   Constraint
      CommE04RA &InitialValueUbox(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Initial Value Ubox", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InitialValueUbox(double value) {
        opt::OptionalE04ZM local_opt;
        return InitialValueUbox(value, local_opt);
      }
      double get_InitialValueUbox(void) {
        std::string local_optstr = "Initial Value Ubox";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Initial Value Ulin:
      //   Default = 1.0
      //   Constraint
      CommE04RA &InitialValueUlin(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Initial Value Ulin", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InitialValueUlin(double value) {
        opt::OptionalE04ZM local_opt;
        return InitialValueUlin(value, local_opt);
      }
      double get_InitialValueUlin(void) {
        std::string local_optstr = "Initial Value Ulin";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Initial Value Unln:
      //   Default = 1.0
      //   Constraint
      CommE04RA &InitialValueUnln(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Initial Value Unln", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InitialValueUnln(double value) {
        opt::OptionalE04ZM local_opt;
        return InitialValueUnln(value, local_opt);
      }
      double get_InitialValueUnln(void) {
        std::string local_optstr = "Initial Value Unln";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Initial X:
      //   Default = "USER"
      //   This parameter guides which starting point x^0 is to be used
      CommE04RA &InitialX(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Initial X", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InitialX(std::string value) {
        opt::OptionalE04ZM local_opt;
        return InitialX(value, local_opt);
      }
      std::string get_InitialX(void) {
        std::string local_optstr = "Initial X";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Inner Iteration Limit:
      //   Default = 100
      //   The maximum number of the inner iterations (Newton steps) to be performed
      //   by Algorithm 2 in each outer iteration
      CommE04RA &InnerIterationLimit(types::f77_integer value,
                                     opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Inner Iteration Limit", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InnerIterationLimit(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return InnerIterationLimit(value, local_opt);
      }
      types::f77_integer get_InnerIterationLimit(void) {
        std::string local_optstr = "Inner Iteration Limit";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // Inner Stop Criteria:
      //   Default = "HEURISTIC"
      //   The precision alpha for the solution of the inner subproblem is determined
      //   in Algorithm 1 and under typical circumstances Algorithm 2 is expected to
      //   reach this precision within the given "Inner Iteration Limit"
      CommE04RA &InnerStopCriteria(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Inner Stop Criteria", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InnerStopCriteria(std::string value) {
        opt::OptionalE04ZM local_opt;
        return InnerStopCriteria(value, local_opt);
      }
      std::string get_InnerStopCriteria(void) {
        std::string local_optstr = "Inner Stop Criteria";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Inner Stop Tolerance:
      //   Default = 10^-2
      //   This option sets the required precision alpha^0 for the first inner problem
      //   solved by Algorithm 2
      CommE04RA &InnerStopTolerance(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Inner Stop Tolerance", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &InnerStopTolerance(double value) {
        opt::OptionalE04ZM local_opt;
        return InnerStopTolerance(value, local_opt);
      }
      double get_InnerStopTolerance(void) {
        std::string local_optstr = "Inner Stop Tolerance";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // LPIPM Algorithm:
      //   Default = "PRIMAL-DUAL"
      //   As described in Algorithmic Details, opt::handle_solve_lp_ipm (e04mt)
      //   implements the infeasible Primal-Dual algorithm, see The
      //   Infeasible-interior-point Primal-Dual Algorithm, and the homogeneous
      //   Self-Dual algorithm, see Homogeneous Self-Dual Algorithm
      CommE04RA &LPIPMAlgorithm(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("LPIPM Algorithm", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMAlgorithm(std::string value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMAlgorithm(value, local_opt);
      }
      std::string get_LPIPMAlgorithm(void) {
        std::string local_optstr = "LPIPM Algorithm";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // LPIPM Centrality Correctors:
      //   Default = 6
      //   This parameter controls the number of centrality correctors (see Weighted
      //   Multiple Centrality Correctors) used at each iteration
      CommE04RA &LPIPMCentralityCorrectors(types::f77_integer value,
                                           opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("LPIPM Centrality Correctors", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMCentralityCorrectors(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMCentralityCorrectors(value, local_opt);
      }
      types::f77_integer get_LPIPMCentralityCorrectors(void) {
        std::string local_optstr = "LPIPM Centrality Correctors";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // LPIPM Iteration Limit:
      //   Default = 100
      //   The maximum number of iterations to be performed by
      //   opt::handle_solve_lp_ipm (e04mt)
      CommE04RA &LPIPMIterationLimit(types::f77_integer value,
                                     opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("LPIPM Iteration Limit", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMIterationLimit(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMIterationLimit(value, local_opt);
      }
      types::f77_integer get_LPIPMIterationLimit(void) {
        std::string local_optstr = "LPIPM Iteration Limit";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // LPIPM Max Iterative Refinement:
      //   Default = 5
      //   This parameter controls the maximum number of iterative refinement
      //   iterations (see Solving the KKT System) used at each main iteration when
      //   "LPIPM System Formulation" = "Normal Equations"
      CommE04RA &LPIPMMaxIterativeRefinement(types::f77_integer value,
                                             opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("LPIPM Max Iterative Refinement", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMMaxIterativeRefinement(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMMaxIterativeRefinement(value, local_opt);
      }
      types::f77_integer get_LPIPMMaxIterativeRefinement(void) {
        std::string local_optstr = "LPIPM Max Iterative Refinement";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // LPIPM Monitor Frequency:
      //   Default = 0
      //   This parameter defines the frequency of how often function monit is called
      CommE04RA &LPIPMMonitorFrequency(types::f77_integer value,
                                       opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("LPIPM Monitor Frequency", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMMonitorFrequency(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMMonitorFrequency(value, local_opt);
      }
      types::f77_integer get_LPIPMMonitorFrequency(void) {
        std::string local_optstr = "LPIPM Monitor Frequency";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // LPIPM Scaling:
      //   Default = "ARITHMETIC"
      //   This parameter controls the type of scaling to be applied on the constraint
      //   matrix A before solving the problem
      CommE04RA &LPIPMScaling(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("LPIPM Scaling", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMScaling(std::string value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMScaling(value, local_opt);
      }
      std::string get_LPIPMScaling(void) {
        std::string local_optstr = "LPIPM Scaling";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // LPIPM Stop Tolerance:
      //   Default = sqrt(epsilon)
      //   This parameter sets the value epsilon_1 which is the tolerance for the
      //   convergence measures in the stopping criteria, see Stopping Criteria
      CommE04RA &LPIPMStopTolerance(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("LPIPM Stop Tolerance", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMStopTolerance(double value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMStopTolerance(value, local_opt);
      }
      double get_LPIPMStopTolerance(void) {
        std::string local_optstr = "LPIPM Stop Tolerance";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // LPIPM Stop Tolerance 2:
      //   Default = epsilon^0.6
      //   This parameter sets the additional tolerance epsilon_2 used in the stopping
      //   criteria for the Self-Dual algorithm, see Stopping Criteria
      CommE04RA &LPIPMStopTolerance2(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("LPIPM Stop Tolerance 2", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMStopTolerance2(double value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMStopTolerance2(value, local_opt);
      }
      double get_LPIPMStopTolerance2(void) {
        std::string local_optstr = "LPIPM Stop Tolerance 2";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // LPIPM System Formulation:
      //   Default = "AUTO"
      //   As described in Solving the KKT System, opt::handle_solve_lp_ipm (e04mt)
      //   can internally work either with the normal equations formulation [equation]
      //   or with the augmented system [equation]
      CommE04RA &LPIPMSystemFormulation(std::string value,
                                        opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("LPIPM System Formulation", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPIPMSystemFormulation(std::string value) {
        opt::OptionalE04ZM local_opt;
        return LPIPMSystemFormulation(value, local_opt);
      }
      std::string get_LPIPMSystemFormulation(void) {
        std::string local_optstr = "LPIPM System Formulation";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // LP Presolve:
      //   Default = "FULL"
      //   This parameter allows you to reduce the level of presolving of the problem
      //   or turn it off completely
      CommE04RA &LPPresolve(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("LP Presolve", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LPPresolve(std::string value) {
        opt::OptionalE04ZM local_opt;
        return LPPresolve(value, local_opt);
      }
      std::string get_LPPresolve(void) {
        std::string local_optstr = "LP Presolve";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Linesearch Mode:
      //   Default = "AUTO"
      //   This controls the step size selection in Algorithm 2
      CommE04RA &LinesearchMode(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Linesearch Mode", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &LinesearchMode(std::string value) {
        opt::OptionalE04ZM local_opt;
        return LinesearchMode(value, local_opt);
      }
      std::string get_LinesearchMode(void) {
        std::string local_optstr = "Linesearch Mode";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // List:
      //   Default = "NO"
      //   This parameter may be set to "YES" if you wish to turn on printing of each
      //   option specification as it is supplied
      CommE04RA &List(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("List", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &List(std::string value) {
        opt::OptionalE04ZM local_opt;
        return List(value, local_opt);
      }
      std::string get_List(void) {
        std::string local_optstr = "List";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Matrix Ordering:
      //   Default = "AUTO"
      //   This parameter specifies the ordering to be used by the internal sparse
      //   linear algebra solver
      CommE04RA &MatrixOrdering(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Matrix Ordering", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &MatrixOrdering(std::string value) {
        opt::OptionalE04ZM local_opt;
        return MatrixOrdering(value, local_opt);
      }
      std::string get_MatrixOrdering(void) {
        std::string local_optstr = "Matrix Ordering";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Monitor Frequency:
      //   Default = 0
      //   If "Monitor Frequency" > 0, the solver returns to you at the end of every
      //   ith outer iteration
      CommE04RA &MonitorFrequency(types::f77_integer value,
                                  opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Monitor Frequency", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &MonitorFrequency(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return MonitorFrequency(value, local_opt);
      }
      types::f77_integer get_MonitorFrequency(void) {
        std::string local_optstr = "Monitor Frequency";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // Monitoring File:
      //   Default = -1
      //   If i >= 0, the unit number for the secondary (monitoring) output
      CommE04RA &MonitoringFile(types::f77_integer value,
                                opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Monitoring File", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &MonitoringFile(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return MonitoringFile(value, local_opt);
      }
      types::f77_integer get_MonitoringFile(void) {
        std::string local_optstr = "Monitoring File";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // Monitoring Level:
      //   Default = 4
      //   This parameter sets the amount of information detail that will be printed
      //   by the solver to the secondary output
      CommE04RA &MonitoringLevel(types::f77_integer value,
                                 opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Monitoring Level", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &MonitoringLevel(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return MonitoringLevel(value, local_opt);
      }
      types::f77_integer get_MonitoringLevel(void) {
        std::string local_optstr = "Monitoring Level";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // Outer Iteration Limit:
      //   Default = 100
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &OuterIterationLimit(types::f77_integer value,
                                     opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Outer Iteration Limit", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &OuterIterationLimit(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return OuterIterationLimit(value, local_opt);
      }
      types::f77_integer get_OuterIterationLimit(void) {
        std::string local_optstr = "Outer Iteration Limit";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // P Min:
      //   Default = sqrt(epsilon)
      //   This controls p_min, the lowest possible penalty value p used for
      //   (standard) inequalities
      CommE04RA &PMin(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("P Min", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &PMin(double value) {
        opt::OptionalE04ZM local_opt;
        return PMin(value, local_opt);
      }
      double get_PMin(void) {
        std::string local_optstr = "P Min";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // P Update Speed:
      //   Default = 12
      //   This option affects the rate at which the penalty options p,P are updated
      //   (Algorithm 1, step (3)) and thus indirectly influences the overall number
      //   of outer iterations
      CommE04RA &PUpdateSpeed(types::f77_integer value,
                              opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("P Update Speed", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &PUpdateSpeed(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return PUpdateSpeed(value, local_opt);
      }
      types::f77_integer get_PUpdateSpeed(void) {
        std::string local_optstr = "P Update Speed";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // Pmat Min:
      //   Default = sqrt(epsilon)
      //   This is an equivalent of "P Min" for the minimal matrix penalty option P_min
      CommE04RA &PmatMin(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Pmat Min", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &PmatMin(double value) {
        opt::OptionalE04ZM local_opt;
        return PmatMin(value, local_opt);
      }
      double get_PmatMin(void) {
        std::string local_optstr = "Pmat Min";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Preference:
      //   Default = "SPEED"
      //   This option affects how contributions from the matrix constraints (6) to
      //   the system Hessian matrix are computed
      CommE04RA &Preference(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Preference", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &Preference(std::string value) {
        opt::OptionalE04ZM local_opt;
        return Preference(value, local_opt);
      }
      std::string get_Preference(void) {
        std::string local_optstr = "Preference";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Presolve Block Detect:
      //   Default = "YES"
      //   If "Presolve Block Detect" = "YES", the matrix constraints are checked
      //   during preprocessoring to determine if they can be split into smaller
      //   independent ones, thus speeding up the solver
      CommE04RA &PresolveBlockDetect(std::string value,
                                     opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Presolve Block Detect", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &PresolveBlockDetect(std::string value) {
        opt::OptionalE04ZM local_opt;
        return PresolveBlockDetect(value, local_opt);
      }
      std::string get_PresolveBlockDetect(void) {
        std::string local_optstr = "Presolve Block Detect";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Print File:
      //   Default = advisory message unit number
      //   If i >= 0, the unit number for the primary output of the solver
      CommE04RA &PrintFile(types::f77_integer value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Print File", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &PrintFile(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return PrintFile(value, local_opt);
      }
      types::f77_integer get_PrintFile(void) {
        std::string local_optstr = "Print File";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // Print Level:
      //   Default = 2
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &PrintLevel(types::f77_integer value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Print Level", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &PrintLevel(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return PrintLevel(value, local_opt);
      }
      types::f77_integer get_PrintLevel(void) {
        std::string local_optstr = "Print Level";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // Print Options:
      //   Default = "YES"
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &PrintOptions(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Print Options", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &PrintOptions(std::string value) {
        opt::OptionalE04ZM local_opt;
        return PrintOptions(value, local_opt);
      }
      std::string get_PrintOptions(void) {
        std::string local_optstr = "Print Options";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Print Solution:
      //   Default = "NO"
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &PrintSolution(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Print Solution", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &PrintSolution(std::string value) {
        opt::OptionalE04ZM local_opt;
        return PrintSolution(value, local_opt);
      }
      std::string get_PrintSolution(void) {
        std::string local_optstr = "Print Solution";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // SOCP Iteration Limit:
      //   Default = 100
      //   The maximum number of iterations to be performed by
      //   opt::handle_solve_socp_ipm (e04pt)
      CommE04RA &SOCPIterationLimit(types::f77_integer value,
                                    opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("SOCP Iteration Limit", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &SOCPIterationLimit(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return SOCPIterationLimit(value, local_opt);
      }
      types::f77_integer get_SOCPIterationLimit(void) {
        std::string local_optstr = "SOCP Iteration Limit";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // SOCP Monitor Frequency:
      //   Default = 0
      //   This parameter defines the frequency of how often function monit is called
      CommE04RA &SOCPMonitorFrequency(types::f77_integer value,
                                      opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("SOCP Monitor Frequency", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &SOCPMonitorFrequency(types::f77_integer value) {
        opt::OptionalE04ZM local_opt;
        return SOCPMonitorFrequency(value, local_opt);
      }
      types::f77_integer get_SOCPMonitorFrequency(void) {
        std::string local_optstr = "SOCP Monitor Frequency";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_ivalue;
      }

      // SOCP Presolve:
      //   Default = "FULL"
      //   This parameter allows you to reduce the level of presolving of the problem
      //   or turn it off completely
      CommE04RA &SOCPPresolve(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("SOCP Presolve", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &SOCPPresolve(std::string value) {
        opt::OptionalE04ZM local_opt;
        return SOCPPresolve(value, local_opt);
      }
      std::string get_SOCPPresolve(void) {
        std::string local_optstr = "SOCP Presolve";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // SOCP Scaling:
      //   Default = "NONE"
      //   This parameter controls the type of scaling to be applied on the constraint
      //   matrix A before solving the problem
      CommE04RA &SOCPScaling(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("SOCP Scaling", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &SOCPScaling(std::string value) {
        opt::OptionalE04ZM local_opt;
        return SOCPScaling(value, local_opt);
      }
      std::string get_SOCPScaling(void) {
        std::string local_optstr = "SOCP Scaling";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // SOCP Stop Tolerance:
      //   Default = sqrt(epsilon)
      //   This parameter sets the value epsilon_1 which is the tolerance for the
      //   convergence measures in the stopping criteria, see Stopping Criteria
      CommE04RA &SOCPStopTolerance(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("SOCP Stop Tolerance", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &SOCPStopTolerance(double value) {
        opt::OptionalE04ZM local_opt;
        return SOCPStopTolerance(value, local_opt);
      }
      double get_SOCPStopTolerance(void) {
        std::string local_optstr = "SOCP Stop Tolerance";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // SOCP Stop Tolerance 2:
      //   Default = sqrt(epsilon)
      //   This parameter sets the additional tolerance epsilon_2 used in the stopping
      //   criteria, see Stopping Criteria
      CommE04RA &SOCPStopTolerance2(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("SOCP Stop Tolerance 2", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &SOCPStopTolerance2(double value) {
        opt::OptionalE04ZM local_opt;
        return SOCPStopTolerance2(value, local_opt);
      }
      double get_SOCPStopTolerance2(void) {
        std::string local_optstr = "SOCP Stop Tolerance 2";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // SOCP System Formulation:
      //   Default = "AUTO"
      //   As described in Solving the KKT System, opt::handle_solve_socp_ipm (e04pt)
      //   can internally work either with the normal equations formulation [equation]
      //   or with the augmented system [equation] and [equation]
      CommE04RA &SOCPSystemFormulation(std::string value,
                                       opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("SOCP System Formulation", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &SOCPSystemFormulation(std::string value) {
        opt::OptionalE04ZM local_opt;
        return SOCPSystemFormulation(value, local_opt);
      }
      std::string get_SOCPSystemFormulation(void) {
        std::string local_optstr = "SOCP System Formulation";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Stats Time:
      //   Default = "NO"
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &StatsTime(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Stats Time", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &StatsTime(std::string value) {
        opt::OptionalE04ZM local_opt;
        return StatsTime(value, local_opt);
      }
      std::string get_StatsTime(void) {
        std::string local_optstr = "Stats Time";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Stop Criteria:
      //   Default = "SOFT"
      //   If "Stop Criteria" = "SOFT", the solver is allowed to stop prematurely with
      //   a suboptimal solution, ifail = 50, if it predicts that a better estimate of
      //   the solution cannot be reached
      CommE04RA &StopCriteria(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Stop Criteria", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &StopCriteria(std::string value) {
        opt::OptionalE04ZM local_opt;
        return StopCriteria(value, local_opt);
      }
      std::string get_StopCriteria(void) {
        std::string local_optstr = "Stop Criteria";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Stop Tolerance 1:
      //   Default = max(10^-6, sqrt(epsilon))
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &StopTolerance1(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Stop Tolerance 1", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &StopTolerance1(double value) {
        opt::OptionalE04ZM local_opt;
        return StopTolerance1(value, local_opt);
      }
      double get_StopTolerance1(void) {
        std::string local_optstr = "Stop Tolerance 1";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Stop Tolerance 2:
      //   Default = max(10^-7, sqrt(epsilon))
      //   This option sets the value epsilon_2 which is used for optimality (2) and
      //   complementarity (4) tests from KKT conditions or if "DIMACS Measures" =
      //   "Check" for all DIMACS error measures instead
      CommE04RA &StopTolerance2(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Stop Tolerance 2", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &StopTolerance2(double value) {
        opt::OptionalE04ZM local_opt;
        return StopTolerance2(value, local_opt);
      }
      double get_StopTolerance2(void) {
        std::string local_optstr = "Stop Tolerance 2";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Stop Tolerance Feasibility:
      //   Default = max(10^-7, sqrt(epsilon))
      //   This parameter places an acceptance limit on the feasibility of the
      //   solution (3), epsilon_feas
      CommE04RA &StopToleranceFeasibility(double value,
                                          opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Stop Tolerance Feasibility", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &StopToleranceFeasibility(double value) {
        opt::OptionalE04ZM local_opt;
        return StopToleranceFeasibility(value, local_opt);
      }
      double get_StopToleranceFeasibility(void) {
        std::string local_optstr = "Stop Tolerance Feasibility";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Task:
      //   Default = "MINIMIZE"
      //   This parameter specifies the required direction of the optimization
      CommE04RA &Task(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Task", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &Task(std::string value) {
        opt::OptionalE04ZM local_opt;
        return Task(value, local_opt);
      }
      std::string get_Task(void) {
        std::string local_optstr = "Task";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // Time Limit:
      //   Default = 10^6
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &TimeLimit(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr = utility::set_optstr("Time Limit", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &TimeLimit(double value) {
        opt::OptionalE04ZM local_opt;
        return TimeLimit(value, local_opt);
      }
      double get_TimeLimit(void) {
        std::string local_optstr = "Time Limit";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Transform Constraints:
      //   Default = "AUTO"
      //   This parameter controls how equality constraints are treated by the solver
      CommE04RA &TransformConstraints(std::string value,
                                      opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Transform Constraints", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &TransformConstraints(std::string value) {
        opt::OptionalE04ZM local_opt;
        return TransformConstraints(value, local_opt);
      }
      std::string get_TransformConstraints(void) {
        std::string local_optstr = "Transform Constraints";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }

      // U Update Restriction:
      //   Default = 0.5
      //   This defines the value mu_g giving the bounds on the updates of Lagrangian
      //   multipliers for (standard) inequalities between the outer iterations
      CommE04RA &UUpdateRestriction(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("U Update Restriction", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &UUpdateRestriction(double value) {
        opt::OptionalE04ZM local_opt;
        return UUpdateRestriction(value, local_opt);
      }
      double get_UUpdateRestriction(void) {
        std::string local_optstr = "U Update Restriction";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Umat Update Restriction:
      //   Default = 0.3
      //   This is an equivalent of "U Update Restriction" for matrix constraints,
      //   denoted as mu_A in Overview
      CommE04RA &UmatUpdateRestriction(double value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Umat Update Restriction", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &UmatUpdateRestriction(double value) {
        opt::OptionalE04ZM local_opt;
        return UmatUpdateRestriction(value, local_opt);
      }
      double get_UmatUpdateRestriction(void) {
        std::string local_optstr = "Umat Update Restriction";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_rvalue;
      }

      // Verify Derivatives:
      //   Default = "NO"
      //   The behaviour of this parameter is solver dependent. Please refer to the
      //   individual solver documentation.
      CommE04RA &VerifyDerivatives(std::string value, opt::OptionalE04ZM &opt) {
        std::string local_optstr =
          utility::set_optstr("Verify Derivatives", value);
        handle_opt_set((*this), local_optstr, opt);
        return (*this);
      }
      CommE04RA &VerifyDerivatives(std::string value) {
        opt::OptionalE04ZM local_opt;
        return VerifyDerivatives(value, local_opt);
      }
      std::string get_VerifyDerivatives(void) {
        std::string local_optstr = "Verify Derivatives";
        types::f77_integer local_ivalue;
        double local_rvalue;
        std::string local_cvalue;
        types::f77_integer local_optype;
        handle_opt_get((*this), local_optstr, local_ivalue, local_rvalue,
                       local_cvalue, local_optype);
        return local_cvalue;
      }
    };
  }
}
#endif
