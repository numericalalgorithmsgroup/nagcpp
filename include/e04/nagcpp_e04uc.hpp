// Header for nagcpp::opt::nlp1_solve (e04uc)

// Copyright 2022, Numerical Algorithms Group Ltd, Oxford, UK.
// Generated by cpp-ft-wrapper.xsl
// Version 28.5.0.0
#ifndef NAGCPP_E04UC_HPP
#define NAGCPP_E04UC_HPP

#include "utility/nagcpp_callback_handling.hpp"
#include "utility/nagcpp_consts.hpp"
#include "utility/nagcpp_data_handling.hpp"
#include "utility/nagcpp_engine_routines.hpp"
#include "utility/nagcpp_engine_types.hpp"
#include "utility/nagcpp_error_handler.hpp"
#include "utility/nagcpp_utility_comm.hpp"
#include "utility/nagcpp_utility_macros.hpp"
#include "utility/nagcpp_utility_optional.hpp"
#include "utility/nagcpp_utility_print_rec.hpp"
#include <algorithm>

namespace nagcpp {
  namespace opt {
    // nlp1_solve (e04uc)
    // Nonlinear programming (NLP), dense, active-set SQP method, using function
    // values and optionally first derivatives, recommended.
    // Note: this function uses optional algorithmic parameters, see also:
    // opt::nlp1_option_file (e04ud), opt::nlp1_option_string (e04ue),
    // opt::nlp1_init (e04wb).
    // opt::nlp1_solve (e04uc) is designed to minimize an arbitrary smooth function
    // subject to constraints (which may include simple bounds on the variables,
    // linear constraints and smooth nonlinear constraints) using a Sequential
    // Quadratic Programming (SQP) method.
    // As many first derivatives as possible should be supplied by you; any
    // unspecified derivatives are approximated by finite differences.
    // It is not intended for large sparse problems.
    // opt::nlp1_solve (e04uc) may also be used for unconstrained,
    // bound-constrained and linearly constrained optimization.
    // opt::nlp1_solve (e04uc) uses forward communication for evaluating the
    // objective function, the nonlinear constraint functions, and any of their
    // derivatives.

    // parameters:
    //   n: types::f77_integer, scalar
    //     n, the number of variables
    //   confun: void, function
    //     confun must calculate the vector c(x) of nonlinear constraint functions
    //     and (optionally) its Jacobian (= dc/dx) for a specified n-element vector x

    //     parameters:
    //       mode: types::f77_integer, scalar
    //         Indicates which values must be assigned during each call of confun
    //       needc: types::f77_integer, array, shape(ncnln)
    //         The indices of the elements of c and/or cjac that must be evaluated by
    //         confun
    //       x: double, array, shape(n)
    //         x, the vector of variables at which the constraint functions and/or the
    //         available elements of the constraint Jacobian are to be evaluated
    //       c: double, array, shape(ncnln)
    //         On exit: if needc[i-1] > 0 and mode = 0 or 2, c[i-1] must contain the
    //         value of the ith constraint at x
    //       cjac: double, array, shape(max(1, ncnln), n)
    //         On entry: unless "Derivative Level" = 2 or 3, the elements of cjac are
    //         set to special values which enable opt::nlp1_solve (e04uc) to detect
    //         whether they are changed by confun
    //         On exit: if needc[i-1] > 0 and mode = 1 or 2, the ith row of cjac must
    //         contain the available elements of the vector nabla c_i given by
    //         nabla c_i = (dc_i/dx_1,dc_i/dx_2,...,dc_i/dx_n)^T,
    //         where dc_i/dx_j is the partial derivative of the ith constraint with
    //         respect to the jth variable, evaluated at the point x
    //       nstate: types::f77_integer, scalar
    //         If nstate = 1, then opt::nlp1_solve (e04uc) is calling confun for the
    //         first time
    //   objfun: void, function
    //     objfun must calculate the objective function F(x) and (optionally) its
    //     gradient g(x) = dF/dx for a specified n-vector x

    //     parameters:
    //       mode: types::f77_integer, scalar
    //         Indicates which values must be assigned during each call of objfun
    //       x: double, array, shape(n)
    //         x, the vector of variables at which the objective function and/or all
    //         available elements of its gradient are to be evaluated
    //       objf: double, scalar
    //         On exit: if mode = 0 or 2, objf must be set to the value of the
    //         objective function at x
    //       objgrd: double, array, shape(n)
    //         On entry: the elements of objgrd are set to special values which enable
    //         opt::nlp1_solve (e04uc) to detect whether they are changed by objfun
    //         On exit: if mode = 1 or 2, objgrd must return the available elements of
    //         the gradient evaluated at x
    //       nstate: types::f77_integer, scalar
    //         If nstate = 1, then opt::nlp1_solve (e04uc) is calling objfun for the
    //         first time
    //   itera: types::f77_integer, scalar
    //     On exit: the number of major iterations performed
    //   istate: types::f77_integer, array, shape(n+nclin+ncnln)
    //     Optionally, on entry: need not be set if the (default) option "Cold Start"
    //     is used
    //     On exit, if not null on entry: the status of the constraints in the QP
    //     working set at the point returned in x
    //   c: double, array, shape(ncnln)
    //     On exit, if not null on entry: if ncnln > 0, c[i-1] contains the value of
    //     the ith nonlinear constraint function c_i at the final iterate, for i =
    //     1,2,...,ncnln
    //   cjac: double, array, shape(ncnln, if ncnln>0: n; otherwise: 1)
    //     Optionally, on entry: in general, cjac need not be initialized before the
    //     call to opt::nlp1_solve (e04uc)
    //     On exit, if not null on entry: if ncnln > 0, cjac contains the Jacobian
    //     matrix of the nonlinear constraint functions at the final iterate, i.e.,
    //     cjac[i-1,j-1] contains the partial derivative of the ith constraint
    //     function with respect to the jth variable, for j = 1,2,...,n, for i =
    //     1,2,...,ncnln
    //   clamda: double, array, shape(n+nclin+ncnln)
    //     Optionally, on entry: need not be set if the (default) option "Cold Start"
    //     is used
    //     On exit, if not null on entry: the values of the QP multipliers from the
    //     last QP subproblem
    //   objf: double, scalar
    //     On exit: the value of the objective function at the final iterate
    //   objgrd: double, array, shape(n)
    //     On exit, if not null on entry: the gradient of the objective function at
    //     the final iterate (or its finite difference approximation)
    //   r: double, array, shape(n, n)
    //     Optionally, on entry: need not be initialized if the (default) option
    //     "Cold Start" is used
    //     On exit, if not null on entry: if "Hessian" = "NO", r contains the upper
    //     triangular Cholesky factor R of Q^TH~Q, an estimate of the transformed and
    //     reordered Hessian of the Lagrangian at x (see (6) in Overview)
    //   nclin: types::f77_integer, scalar
    //     n_L, the number of general linear constraints
    //   x: double, array, shape(n)
    //     On entry: an initial estimate of the solution
    //     On exit: the final estimate of the solution
    //   comm: opt::CommE04WB, scalar
    //     Communication structure
    //     An object of either the derived class opt::CommE04WB or its base class
    //     utility::CopyableComm can be supplied.
    //     It is recommended that the derived class is used. If the base class is
    //     supplied it must
    //     first be initialized via a call to opt::nlp1_init (e04wb).
    //   a: double, array, shape(nclin, if nclin>0: n; otherwise: 1)
    //     The ith row of a contains the ith row of the matrix A_L of general linear
    //     constraints in (1). That is, the ith row contains the coefficients of the
    //     ith general linear constraint, for i = 1,2,...,nclin
    //   bl: double, array, shape(n+nclin+ncnln)
    //     bl must contain the lower bounds for all the constraints
    //   bu: double, array, shape(n+nclin+ncnln)
    //     bu must contain the upper bounds for all the constraints
    //   opt: opt::OptionalE04UC
    //     Optional parameter container, derived from utility::Optional.
    //     contains:
    //       fail: error_handler::ErrorHandler

    // other parameters:
    //   Central Difference Interval: double
    //     Default values are computed
    //     If the algorithm switches to central differences because the
    //     forward-difference approximation is not sufficiently accurate, the value
    //     of r is used as the difference interval for every element of x
    //   Cold Start: valueless
    //     Default
    //     This option controls the specification of the initial working set in both
    //     the procedure for finding a feasible point for the linear constraints and
    //     bounds and in the first QP subproblem thereafter
    //   Warm Start: valueless
    //     This option controls the specification of the initial working set in both
    //     the procedure for finding a feasible point for the linear constraints and
    //     bounds and in the first QP subproblem thereafter
    //   Crash Tolerance: double
    //     Default = 0.01
    //     This value is used in conjunction with the option "Cold Start" (the
    //     default value) when opt::nlp1_solve (e04uc) selects an initial working set
    //   Defaults: valueless
    //     This special keyword may be used to reset all options to their default
    //     values
    //   Derivative Level: types::f77_integer
    //     Default = 3
    //     This parameter indicates which derivatives are provided in functions
    //     objfun and confun
    //   Difference Interval: double
    //     Default values are computed
    //     This option defines an interval used to estimate derivatives by finite
    //     differences in the following circumstances
    //   Feasibility Tolerance: double
    //     Default = sqrt(epsilon)
    //     The scalar r defines the maximum acceptable absolute violations in linear
    //     and nonlinear constraints at a "feasible" point; i.e., a constraint is
    //     considered satisfied if its violation does not exceed r
    //   Function Precision: double
    //     Default = epsilon^0.9
    //     This parameter defines epsilon_r, which is intended to be a measure of the
    //     accuracy with which the problem functions F(x) and c(x) can be computed
    //   Hessian: char
    //     Default = NO
    //     This option controls the contents of the upper triangular matrix R (see
    //     Arguments)
    //   Infinite Bound Size: double
    //     Default = 10^20
    //     If r > 0, r defines the "infinite" bound bigbnd in the definition of the
    //     problem constraints
    //   Infinite Step Size: double
    //     Default = max(bigbnd, 10^20)
    //     If r > 0, r specifies the magnitude of the change in variables that is
    //     treated as a step to an unbounded solution
    //   Line Search Tolerance: double
    //     Default = 0.9
    //     The value r (0 <= r < 1) controls the accuracy with which the step alpha
    //     taken during each iteration approximates a minimum of the merit function
    //     along the search direction (the smaller the value of r, the more accurate
    //     the linesearch)
    //   Linear Feasibility Tolerance: double
    //     Default = sqrt(epsilon)
    //     The default value of r_2 is epsilon^0.33 if "Derivative Level" = 0 or 1,
    //     and sqrt(epsilon) otherwise
    //   Nonlinear Feasibility Tolerance: double
    //     Default = epsilon^0.33 or sqrt(epsilon)
    //     The default value of r_2 is epsilon^0.33 if "Derivative Level" = 0 or 1,
    //     and sqrt(epsilon) otherwise
    //   List: valueless
    //     Option "List" enables printing of each option specification as it is
    //     supplied
    //   Nolist: valueless
    //     Default
    //     Option "List" enables printing of each option specification as it is
    //     supplied
    //   Major Iteration Limit: types::f77_integer
    //     Default = max(50, 3*(n+n_L)+10*n_N)
    //     The value of i specifies the maximum number of major iterations allowed
    //     before termination
    //   Iteration Limit: types::f77_integer
    //     Default = max(50, 3*(n+n_L)+10*n_N)
    //     The value of i specifies the maximum number of major iterations allowed
    //     before termination
    //   Iters: types::f77_integer
    //     Default = max(50, 3*(n+n_L)+10*n_N)
    //     The value of i specifies the maximum number of major iterations allowed
    //     before termination
    //   Itns: types::f77_integer
    //     Default = max(50, 3*(n+n_L)+10*n_N)
    //     The value of i specifies the maximum number of major iterations allowed
    //     before termination
    //   Major Print Level: types::f77_integer
    //     The value of i controls the amount of printout produced by the major
    //     iterations of opt::nlp1_solve (e04uc), as indicated below
    //   Print Level: types::f77_integer
    //     Default for opt::nlp1_solve (e04uc) = 0
    //     The value of i controls the amount of printout produced by the major
    //     iterations of opt::nlp1_solve (e04uc), as indicated below
    //   Minor Iteration Limit: types::f77_integer
    //     Default = max(50, 3*(n+n_L+n_N))
    //     The value of i specifies the maximum number of iterations for finding a
    //     feasible point with respect to the bounds and linear constraints (if any)
    //   Minor Print Level: types::f77_integer
    //     Default = 0
    //     The value of i controls the amount of printout produced by the minor
    //     iterations of opt::nlp1_solve (e04uc) (i.e., the iterations of the
    //     quadratic programming algorithm), as indicated below
    //   Monitoring File: types::f77_integer
    //     Default = -1
    //     If i >= 0 and "Major Print Level" >= 5 or i >= 0 and "Minor Print Level"
    //     >= 5, monitoring information produced by opt::nlp1_solve (e04uc) at every
    //     iteration is sent to a file with logical unit number i
    //   Optimality Tolerance: double
    //     Default = epsilon_r^0.8
    //     The parameter r (epsilon_r <= r < 1) specifies the accuracy to which you
    //     wish the final iterate to approximate a solution of the problem
    //   Start Objective Check At Variable: types::f77_integer
    //     Default = 1
    //     These keywords take effect only if "Verify Level" > 0
    //   Stop Objective Check At Variable: types::f77_integer
    //     Default = n
    //     These keywords take effect only if "Verify Level" > 0
    //   Start Constraint Check At Variable: types::f77_integer
    //     Default = 1
    //     These keywords take effect only if "Verify Level" > 0
    //   Stop Constraint Check At Variable: types::f77_integer
    //     Default = n
    //     These keywords take effect only if "Verify Level" > 0
    //   Step Limit: double
    //     Default = 2.0
    //     If r > 0,r specifies the maximum change in variables at the first step of
    //     the linesearch
    //   Verify Level: types::f77_integer
    //     Default = 0
    //     These keywords refer to finite difference checks on the gradient elements
    //     computed by objfun and confun
    //   Verify: valueless
    //     These keywords refer to finite difference checks on the gradient elements
    //     computed by objfun and confun
    //   Verify Constraint Gradients: valueless
    //     These keywords refer to finite difference checks on the gradient elements
    //     computed by objfun and confun
    //   Verify Gradients: valueless
    //     These keywords refer to finite difference checks on the gradient elements
    //     computed by objfun and confun
    //   Verify Objective Gradients: valueless
    //     These keywords refer to finite difference checks on the gradient elements
    //     computed by objfun and confun

    // error_handler::CallbackEarlyTermination
    //   (errorid i < 0)
    //     User requested termination by setting mode negative in objfun or confun.

    // error_handler::WarningException
    //   (errorid 1)
    //     Optimal solution found, but requested accuracy not achieved.
    //   (errorid 2)
    //     No feasible point for the linear constraints.
    //   (errorid 3)
    //     No feasible point for the nonlinear constraints.
    //   (errorid 4)
    //     Too many major iterations.
    //   (errorid 6)
    //     Current point cannot be improved upon.

    // error_handler::ErrorException
    //   (errorid 7)
    //     Large errors found in the derivatives.
    //   (errorid 9)
    //     On entry, n = <value>.
    //     Constraint: n > 0.
    //   (errorid 9)
    //     On entry, nclin = <value>.
    //     Constraint: nclin >= 0.
    //   (errorid 9)
    //     On entry, ncnln = <value>.
    //     Constraint: ncnln >= 0.
    //   (errorid 9)
    //     On entry, the equal bounds on <value> are infinite, because
    //     bl[<value>] = beta and bu[<value>] = beta,
    //     but abs(beta) >= bigbnd: beta = <value> and
    //     bigbnd = <value>.
    //   (errorid 9)
    //     On entry, the bounds on <value> are inconsistent:
    //     bl[<value>] = <value> and
    //     bu[<value>] = <value>.
    //   (errorid 9)
    //     On entry with a Warm Start,
    //     istate[<value>] = <value>.
    //   (errorid 9)
    //     On entry, the equal bounds on variable <value> are
    //     infinite, because bl[<value>] = beta and
    //     bu[<value>] = beta, but abs(beta) >= bigbnd:
    //     beta = <value> and bigbnd = <value>.
    //   (errorid 9)
    //     On entry, the equal bounds on linear constraint <value> are
    //     infinite, because bl[<value>] = beta and
    //     bu[<value>] = beta, but abs(beta) >= bigbnd:
    //     beta = <value> and bigbnd = <value>.
    //   (errorid 9)
    //     On entry, the equal bounds on nonlinear constraint <value>
    //     are infinite, because bl[<value>] = beta and
    //     bu[<value>] = beta, but abs(beta) >= bigbnd:
    //     beta = <value> and bigbnd = <value>.
    //   (errorid 9)
    //     On entry, the bounds on variable <value> are
    //     inconsistent: bl[<value>] = <value>
    //     and bu[<value>] = <value>.
    //   (errorid 9)
    //     On entry, the bounds on linear constraint <value> are
    //     inconsistent: bl[<value>] = <value>
    //     and bu[<value>] = <value>.
    //   (errorid 9)
    //     On entry, the bounds on nonlinear constraint <value> are
    //     inconsistent: bl[<value>] = <value>
    //     and bu[<value>] = <value>.
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     Supplied argument has <value> dimensions.
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     Supplied argument was a vector of size <value>.
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     The size for the supplied array could not be ascertained.
    //   (errorid 10601)
    //     On entry, argument <value> must be a <value> x <value> array.
    //     Supplied argument has <value> dimensions.
    //   (errorid 10601)
    //     On entry, argument <value> must be a <value> x <value> array.
    //     Supplied argument was a <value> x <value> array.
    //   (errorid 10601)
    //     On entry, argument <value> must be a <value> x <value> array.
    //     Not all of the sizes for the supplied array could be ascertained.
    //   (errorid 10602)
    //     On entry, the raw data component of <value> is null.
    //   (errorid 10603)
    //     On entry, unable to ascertain a value for <value>.
    //   (errorid 10604)
    //     On entry, the data in <value> is stored in <value> Major Order.
    //     The data was expected to be in <value> Major Order.
    //   (errorid 10605)
    //     On entry, the communication class <value> has not been initialized
    //     correctly.
    //   (errorid 10703)
    //     An exception was thrown during IO (writing).
    //   (errorid -99)
    //     An unexpected error has been triggered by this routine.
    //   (errorid -399)
    //     Your licence key may have expired or may not have been installed correctly.
    //   (errorid -999)
    //     Dynamic memory allocation failed.

    // error_handler::CallbackException
    //   (errorid 10701)
    //     An exception was thrown in a callback.
    //   (errorid 10702)
    //     The memory address for an array in a callback has changed.

    extern "C" {
#ifndef E04UCFT_CONFUN
#define E04UCFT_CONFUN                                                    \
  std::function<void(                                                     \
    const data_handling::CallbackAddresses *, types::engine_data &,       \
    const types::f77_integer,                                             \
    const utility::array1D<types::f77_integer,                            \
                           data_handling::ArgIntent::IntentIN> &,         \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    utility::array1D<double, data_handling::ArgIntent::IntentOUT> &,      \
    utility::array2D<double, data_handling::ArgIntent::IntentINOUT> &,    \
    const types::f77_integer)>
#endif

#ifndef E04UCFT_CONFUNH
#define E04UCFT_CONFUNH                                                     \
  void(NAG_CALL * confunh)(                                                 \
    const E04UCFT_CONFUN &, types::engine_data &, types::f77_integer &,     \
    const types::f77_integer &, const types::f77_integer &,                 \
    const types::f77_integer &, const types::f77_integer[], const double[], \
    double[], double[], const types::f77_integer &, void *, void *)
#endif

#ifndef E04UCFT_OBJFUN
#define E04UCFT_OBJFUN                                                    \
  std::function<void(                                                     \
    const data_handling::CallbackAddresses *, types::engine_data &,       \
    const types::f77_integer,                                             \
    const utility::array1D<double, data_handling::ArgIntent::IntentIN> &, \
    double &,                                                             \
    utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &,    \
    const types::f77_integer)>
#endif

#ifndef E04UCFT_OBJFUNH
#define E04UCFT_OBJFUNH                                                      \
  void(NAG_CALL * objfunh)(const E04UCFT_OBJFUN &, types::engine_data &,     \
                           types::f77_integer &, const types::f77_integer &, \
                           const double[], double &, double[],               \
                           const types::f77_integer &, void *, void *)
#endif

#if defined(_WIN32) && defined(USE_STDCALL)
#define e04ucft_(en_data, print_rec, print_rech, n, nclin, ncnln, lda, ldcj,   \
                 ldr, a, bl, bu, confun, confunh, objfun, objfunh, itera,      \
                 istate, c, cjac, clamda, objf, objgrd, r, x, iwork, liwork,   \
                 work, lwork, iuser, ruser, lwsav, iwsav, rwsav, routine_name, \
                 errbuf, ifail, routine_name_length, errbuf_length)            \
  E04UCFT(en_data, print_rec, print_rech, n, nclin, ncnln, lda, ldcj, ldr, a,  \
          bl, bu, confun, confunh, objfun, objfunh, itera, istate, c, cjac,    \
          clamda, objf, objgrd, r, x, iwork, liwork, work, lwork, iuser,       \
          ruser, lwsav, iwsav, rwsav, routine_name, routine_name_length,       \
          errbuf, errbuf_length, ifail)
#elif defined(_WIN32) || defined(_WIN64)
#define e04ucft_ E04UCFT
#else
#define E04UCFT e04ucft_
#endif
    extern void NAG_CALL E04UCFT(
      types::engine_data &en_data, void *print_rec, NAG_PRINT_RECH,
      const types::f77_integer &n, const types::f77_integer &nclin,
      const types::f77_integer &ncnln, const types::f77_integer &lda,
      const types::f77_integer &ldcj, const types::f77_integer &ldr,
      const double a[], const double bl[], const double bu[],
      const E04UCFT_CONFUN &, E04UCFT_CONFUNH, const E04UCFT_OBJFUN &,
      E04UCFT_OBJFUNH, types::f77_integer &itera, types::f77_integer istate[],
      double c[], double cjac[], double clamda[], double &objf, double objgrd[],
      double r[], double x[], types::f77_integer iwork[],
      const types::f77_integer &liwork, double work[],
      const types::f77_integer &lwork, void *iuser, void *ruser,
      types::f77_logical lwsav[], types::f77_integer iwsav[], double rwsav[],
      const char *routine_name NAG_STDCALL_LEN(routine_name_length),
      char *errbuf NAG_STDCALL_LEN(errbuf_length),
      types::f77_integer &ifail NAG_NSTDCALL_LEN(routine_name_length)
        NAG_NSTDCALL_LEN(errbuf_length));
    }

    class CommE04WB;

    class OptionalE04UC : public utility::Optional {
    public:
      OptionalE04UC() : Optional() {}
      template <typename A, typename BL, typename BU, typename CONFUN,
                typename OBJFUN, typename ISTATE, typename C, typename CJAC,
                typename CLAMDA, typename OBJGRD, typename R, typename X,
                typename COMM>
      friend void nlp1_solve(const A &a, const BL &bl, const BU &bu,
                             CONFUN &&confun, OBJFUN &&objfun,
                             types::f77_integer &itera, ISTATE &&istate, C &&c,
                             CJAC &&cjac, CLAMDA &&clamda, double &objf,
                             OBJGRD &&objgrd, R &&r, X &&x, COMM &comm,
                             opt::OptionalE04UC &opt);
    };

    void
      e04uc_confunh(const E04UCFT_CONFUN &confun, types::engine_data &en_data,
                    types::f77_integer &mode, const types::f77_integer &ncnln,
                    const types::f77_integer &n, const types::f77_integer &ldcj,
                    const types::f77_integer *needc, const double *x, double *c,
                    double *cjac, const types::f77_integer &nstate, void *iuser,
                    void *ruser) {
      error_handler::ExceptionPointer *ep =
        static_cast<error_handler::ExceptionPointer *>(en_data.wrapptr1);
      utility::array1D<types::f77_integer, data_handling::ArgIntent::IntentIN>
        local_needc(needc, ncnln);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_x(x,
                                                                           n);
      utility::array1D<double, data_handling::ArgIntent::IntentOUT> local_c(
        c, ncnln);
      utility::array2D<double, data_handling::ArgIntent::IntentINOUT>
        local_cjac(cjac, std::max(static_cast<types::f77_integer>(1), ncnln),
                   n);
      data_handling::CallbackAddresses *callbacks =
        static_cast<data_handling::CallbackAddresses *>(en_data.wrapptr2);

      try {
        confun(callbacks, en_data, mode, local_needc, local_x, local_c,
               local_cjac, nstate);

      } catch (const error_handler::CallbackEarlyTermination &e) {
        // user threw an early termination exception
        NAG_UNUSED_PARAMETER(e);
        en_data.hlperr = 0;
        mode = -1;
        ep->eptr = std::current_exception();

      } catch (...) {
        // callback threw an exception
        en_data.hlperr = error_handler::HLPERR_USER_EXCEPTION;
        ep->eptr = std::current_exception();
      }

      if ((needc != local_needc.data()) && (x != local_x.data()) &&
          (c != local_c.data()) && (cjac != local_cjac.data())) {
        // address of an array changed
        en_data.hlperr = error_handler::HLPERR_ARRAY_POINTER_CHANGED;
        return;
      }
    }

    template <typename CONFUN_NEEDC, typename CONFUN_X, typename CONFUN_C,
              typename CONFUN_CJAC, typename CONFUN>
    struct e04uc_confun_cs {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data, const types::f77_integer mode,
        const utility::array1D<types::f77_integer,
                               data_handling::ArgIntent::IntentIN> &needc,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        utility::array1D<double, data_handling::ArgIntent::IntentOUT> &c,
        utility::array2D<double, data_handling::ArgIntent::IntentINOUT> &cjac,
        const types::f77_integer nstate) {
        CONFUN &confun =
          *((typename std::remove_reference<CONFUN>::type *)(*callbacks)
              .address[0]);

        auto local_needc = data_handling::convert_nag_array_to_user<
          const utility::array1D<types::f77_integer,
                                 data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, CONFUN_NEEDC>(needc);
        auto local_x = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, CONFUN_X>(x);
        auto local_c = data_handling::convert_nag_array_to_user<
          utility::array1D<double, data_handling::ArgIntent::IntentOUT>,
          data_handling::ArgIntent::IntentOUT, CONFUN_C>(c);
        auto local_cjac = data_handling::convert_nag_array_to_user<
          utility::array2D<double, data_handling::ArgIntent::IntentINOUT>,
          data_handling::ArgIntent::IntentINOUT, CONFUN_CJAC>(cjac);

        confun(mode, local_needc.get(), local_x.get(), local_c.get(),
               local_cjac.get(), nstate);
      }
    };

    template <>
    struct e04uc_confun_cs<std::nullptr_t, std::nullptr_t, std::nullptr_t,
                           std::nullptr_t, std::nullptr_t> {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data, const types::f77_integer mode,
        const utility::array1D<types::f77_integer,
                               data_handling::ArgIntent::IntentIN> &needc,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        utility::array1D<double, data_handling::ArgIntent::IntentOUT> &c,
        utility::array2D<double, data_handling::ArgIntent::IntentINOUT> &cjac,
        const types::f77_integer nstate) {
        return;
      }
    };

    void e04uc_objfunh(const E04UCFT_OBJFUN &objfun,
                       types::engine_data &en_data, types::f77_integer &mode,
                       const types::f77_integer &n, const double *x,
                       double &objf, double *objgrd,
                       const types::f77_integer &nstate, void *iuser,
                       void *ruser) {
      error_handler::ExceptionPointer *ep =
        static_cast<error_handler::ExceptionPointer *>(en_data.wrapptr1);
      utility::array1D<double, data_handling::ArgIntent::IntentIN> local_x(x,
                                                                           n);
      utility::array1D<double, data_handling::ArgIntent::IntentINOUT>
        local_objgrd(objgrd, n);
      data_handling::CallbackAddresses *callbacks =
        static_cast<data_handling::CallbackAddresses *>(en_data.wrapptr2);

      try {
        objfun(callbacks, en_data, mode, local_x, objf, local_objgrd, nstate);

      } catch (const error_handler::CallbackEarlyTermination &e) {
        // user threw an early termination exception
        NAG_UNUSED_PARAMETER(e);
        en_data.hlperr = 0;
        mode = -1;
        ep->eptr = std::current_exception();

      } catch (...) {
        // callback threw an exception
        en_data.hlperr = error_handler::HLPERR_USER_EXCEPTION;
        ep->eptr = std::current_exception();
      }

      if ((x != local_x.data()) && (objgrd != local_objgrd.data())) {
        // address of an array changed
        en_data.hlperr = error_handler::HLPERR_ARRAY_POINTER_CHANGED;
        return;
      }
    }

    template <typename OBJFUN_X, typename OBJFUN_OBJGRD, typename OBJFUN>
    struct e04uc_objfun_cs {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data, const types::f77_integer mode,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        double &objf,
        utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &objgrd,
        const types::f77_integer nstate) {
        OBJFUN &objfun =
          *((typename std::remove_reference<OBJFUN>::type *)(*callbacks)
              .address[1]);

        auto local_x = data_handling::convert_nag_array_to_user<
          const utility::array1D<double, data_handling::ArgIntent::IntentIN>,
          data_handling::ArgIntent::IntentIN, OBJFUN_X>(x);
        auto local_objgrd = data_handling::convert_nag_array_to_user<
          utility::array1D<double, data_handling::ArgIntent::IntentINOUT>,
          data_handling::ArgIntent::IntentINOUT, OBJFUN_OBJGRD>(objgrd);

        objfun(mode, local_x.get(), objf, local_objgrd.get(), nstate);
      }
    };

    template <>
    struct e04uc_objfun_cs<std::nullptr_t, std::nullptr_t, std::nullptr_t> {
      static void run(
        const data_handling::CallbackAddresses *callbacks,
        types::engine_data &en_data, const types::f77_integer mode,
        const utility::array1D<double, data_handling::ArgIntent::IntentIN> &x,
        double &objf,
        utility::array1D<double, data_handling::ArgIntent::IntentINOUT> &objgrd,
        const types::f77_integer nstate) {
        return;
      }
    };

    template <typename A, typename BL, typename BU, typename CONFUN,
              typename OBJFUN, typename ISTATE, typename C, typename CJAC,
              typename CLAMDA, typename OBJGRD, typename R, typename X,
              typename COMM>
    void nlp1_solve(const A &a, const BL &bl, const BU &bu, CONFUN &&confun,
                    OBJFUN &&objfun, types::f77_integer &itera, ISTATE &&istate,
                    C &&c, CJAC &&cjac, CLAMDA &&clamda, double &objf,
                    OBJGRD &&objgrd, R &&r, X &&x, COMM &comm,
                    opt::OptionalE04UC &opt) {
      opt.fail.prepare("opt::nlp1_solve (e04uc)");
      types::engine_data en_data;
      engine_routines::y90haan_(en_data);
      en_data.allocate_workspace = constants::NAG_ED_YES;
      error_handler::ExceptionPointer ep;
      en_data.wrapptr1 = &ep;
      data_handling::RawData<double, data_handling::ArgIntent::IntentIN,
                             typename std::remove_reference<A>::type>
        local_a(a);
      data_handling::RawData<double, data_handling::ArgIntent::IntentIN,
                             typename std::remove_reference<BL>::type>
        local_bl(bl);
      data_handling::RawData<double, data_handling::ArgIntent::IntentIN,
                             typename std::remove_reference<BU>::type>
        local_bu(bu);
      data_handling::CallbackAddresses callbacks(2);
      en_data.wrapptr2 = static_cast<void *>(std::addressof(callbacks));
      callbacks.address[0] =
        callback_handling::function_to_void_pointer(confun);
      static_assert(
        !(std::is_same<std::nullptr_t,
                       typename std::remove_reference<OBJFUN>::type>::value),
        "nullptr is not a valid input as no default function is available for "
        "objfun");
      callbacks.address[1] =
        callback_handling::function_to_void_pointer(objfun);
      data_handling::RawData<types::f77_integer,
                             data_handling::ArgIntent::IntentINOUT,
                             typename std::remove_reference<ISTATE>::type>
        local_istate(istate);
      data_handling::RawData<double, data_handling::ArgIntent::IntentINOUT,
                             typename std::remove_reference<CJAC>::type>
        local_cjac(cjac);
      data_handling::RawData<double, data_handling::ArgIntent::IntentINOUT,
                             typename std::remove_reference<CLAMDA>::type>
        local_clamda(clamda);
      data_handling::RawData<double, data_handling::ArgIntent::IntentINOUT,
                             typename std::remove_reference<R>::type>
        local_r(r);
      data_handling::RawData<double, data_handling::ArgIntent::IntentINOUT,
                             typename std::remove_reference<X>::type>
        local_x(x);
      static_assert(std::is_same<COMM, utility::CopyableComm>::value ||
                      std::is_same<COMM, opt::CommE04WB>::value,
                    "Invalid type for comm: must be either "
                    "utility::CopyableComm or opt::CommE04WB");
      if (!(comm.check(0, 400))) {
        opt.fail.raise_error_comm_invalid("comm");
        if (opt.fail.error_thrown) {
          return;
        }
      }

      void *local_print_rec = static_cast<void *>(&opt.iomanager);
      types::f77_integer local_n =
        data_handling::get_size(opt.fail, "n", local_x, 1, local_r, 1, local_r,
                                2);
      if (opt.fail.error_thrown) {
        return;
      }
      types::f77_integer local_nclin =
        data_handling::get_size(opt.fail, "nclin", local_a, 1);
      if (opt.fail.error_thrown) {
        return;
      }
      types::f77_integer local_ncnln =
        data_handling::get_size(opt.fail, "ncnln", local_bl, 1) - local_n -
        local_nclin;
      using local_confun_needc_t = callback_handling::get_argument_type_t<
        1, callback_handling::argument_type_of_t<
             typename std::remove_reference<CONFUN>::type>>;
      using local_confun_x_t = callback_handling::get_argument_type_t<
        2, callback_handling::argument_type_of_t<
             typename std::remove_reference<CONFUN>::type>>;
      using local_confun_c_t = callback_handling::get_argument_type_t<
        3, callback_handling::argument_type_of_t<
             typename std::remove_reference<CONFUN>::type>>;
      using local_confun_cjac_t = callback_handling::get_argument_type_t<
        4, callback_handling::argument_type_of_t<
             typename std::remove_reference<CONFUN>::type>>;
      auto local_confun =
        e04uc_confun_cs<local_confun_needc_t, local_confun_x_t,
                        local_confun_c_t, local_confun_cjac_t,
                        typename std::remove_reference<CONFUN>::type>::run;
      using local_objfun_x_t = callback_handling::get_argument_type_t<
        1, callback_handling::argument_type_of_t<
             typename std::remove_reference<OBJFUN>::type>>;
      using local_objfun_objgrd_t = callback_handling::get_argument_type_t<
        3, callback_handling::argument_type_of_t<
             typename std::remove_reference<OBJFUN>::type>>;
      auto local_objfun =
        e04uc_objfun_cs<local_objfun_x_t, local_objfun_objgrd_t,
                        typename std::remove_reference<OBJFUN>::type>::run;
      if (!(local_istate.data)) {
        if (comm.icomm[400] == 1) {
          opt.fail.raise_error_array_null("istate");
          if (opt.fail.error_thrown) {
            return;
          }
        }
        local_istate.resize(istate, local_n + local_nclin + local_ncnln);
      }
      data_handling::RawData<double, data_handling::ArgIntent::IntentOUT,
                             typename std::remove_reference<C>::type>
        local_c(c);
      local_c.resize(c, local_ncnln);
      types::f77_integer local_cjac_dim2;
      if (local_ncnln > 0) {
        local_cjac_dim2 = local_n;
      } else {
        local_cjac_dim2 = 1;
      }
      if (!(local_cjac.data)) {
        if ((comm.icomm[151] == 2 || comm.icomm[151] == 3) &&
            local_ncnln != 0) {
          opt.fail.raise_error_array_null("cjac");
          if (opt.fail.error_thrown) {
            return;
          }
        }
        if (local_ncnln != 0) {
          local_cjac.resize(cjac, local_ncnln, local_cjac_dim2);
        }
      }
      if (!(local_clamda.data)) {
        if (comm.icomm[400] == 1) {
          opt.fail.raise_error_array_null("clamda");
          if (opt.fail.error_thrown) {
            return;
          }
        }
        local_clamda.resize(clamda, local_n + local_nclin + local_ncnln);
      }
      data_handling::RawData<double, data_handling::ArgIntent::IntentOUT,
                             typename std::remove_reference<OBJGRD>::type>
        local_objgrd(objgrd);
      local_objgrd.resize(objgrd, local_n);
      if (!(local_r.data)) {
        if (comm.icomm[400] == 1) {
          opt.fail.raise_error_array_null("r");
          if (opt.fail.error_thrown) {
            return;
          }
        }
        local_r.resize(r, local_n, local_n);
      }
      data_handling::RawData<types::f77_integer,
                             data_handling::ArgIntent::IntentOUT>
        local_iwork(static_cast<types::f77_integer>(0));
      types::f77_integer local_liwork = 0;
      data_handling::RawData<double, data_handling::ArgIntent::IntentOUT>
        local_work(static_cast<types::f77_integer>(0));
      types::f77_integer local_lwork = 0;
      void *local_iuser = nullptr;
      void *local_ruser = nullptr;
      data_handling::StringRawData<data_handling::ArgIntent::IntentIN>
        local_routine_name("e04uc ");
      types::f77_integer local_storage_order =
        data_handling::get_storage_order(opt.default_to_col_major, local_a,
                                         local_cjac, local_r);
      en_data.storage_order = local_storage_order;

      local_x.check(opt.fail, "x", true, local_n);
      if (opt.fail.error_thrown) {
        return;
      }
      local_r.check(opt.fail, "r", true, local_storage_order, local_n, local_n);
      if (opt.fail.error_thrown) {
        return;
      }
      local_objgrd.check(opt.fail, "objgrd", true, local_n);
      if (opt.fail.error_thrown) {
        return;
      }
      local_clamda.check(opt.fail, "clamda", true,
                         local_n + local_nclin + local_ncnln);
      if (opt.fail.error_thrown) {
        return;
      }
      bool cjac_is_required = (local_ncnln != 0);
      local_cjac.check(opt.fail, "cjac", cjac_is_required, local_storage_order,
                       local_ncnln, local_cjac_dim2);
      if (opt.fail.error_thrown) {
        return;
      }
      bool c_is_required = (local_ncnln != 0);
      local_c.check(opt.fail, "c", c_is_required, local_ncnln);
      if (opt.fail.error_thrown) {
        return;
      }
      local_istate.check(opt.fail, "istate", true,
                         local_n + local_nclin + local_ncnln);
      if (opt.fail.error_thrown) {
        return;
      }
      local_bu.check(opt.fail, "bu", true, local_n + local_nclin + local_ncnln);
      if (opt.fail.error_thrown) {
        return;
      }
      local_bl.check(opt.fail, "bl", true, local_n + local_nclin + local_ncnln);
      if (opt.fail.error_thrown) {
        return;
      }
      types::f77_integer local_a_dim2;
      if (local_nclin > 0) {
        local_a_dim2 = local_n;
      } else {
        local_a_dim2 = 1;
      }
      local_a.check(opt.fail, "a", true, local_storage_order, local_nclin,
                    local_a_dim2);
      if (opt.fail.error_thrown) {
        return;
      }
      types::f77_integer local_ldr = local_r.get_LD(local_storage_order);
      types::f77_integer local_ldcj =
        std::max(static_cast<types::f77_integer>(1),
                 local_cjac.get_LD(local_storage_order));
      types::f77_integer local_lda =
        std::max(static_cast<types::f77_integer>(1),
                 local_a.get_LD(local_storage_order));

      e04ucft_(en_data, local_print_rec, utility::print_rech, local_n,
               local_nclin, local_ncnln, local_lda, local_ldcj, local_ldr,
               local_a.data, local_bl.data, local_bu.data, local_confun,
               e04uc_confunh, local_objfun, e04uc_objfunh, itera,
               local_istate.data, local_c.data, local_cjac.data,
               local_clamda.data, objf, local_objgrd.data, local_r.data,
               local_x.data, local_iwork.data, local_liwork, local_work.data,
               local_lwork, local_iuser, local_ruser, comm.lcomm, comm.icomm,
               comm.rcomm, local_routine_name.data, opt.fail.errbuf,
               opt.fail.errorid, local_routine_name.string_length,
               opt.fail.errbuf_length);

      if (!(opt.fail.initial_error_handler(en_data))) {
        if (opt.fail.ierr < 0 && opt.fail.ifmt == 99999) {
          opt.fail.set_errorid(opt.fail.ierr,
                               error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "User requested termination by setting "
                                     "mode negative in objfun or confun.");
          opt.fail.append_exception_msg(en_data);
        } else if (opt.fail.ierr == 1 && opt.fail.ifmt == 1) {
          opt.fail.set_errorid(1, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "Optimal solution found, but requested "
                                     "accuracy not achieved.");
        } else if (opt.fail.ierr == 2 && opt.fail.ifmt == 1) {
          opt.fail.set_errorid(2, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "No feasible point for the linear "
                                     "constraints.");
        } else if (opt.fail.ierr == 3 && opt.fail.ifmt == 1) {
          opt.fail.set_errorid(3, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "No feasible point for the nonlinear "
                                     "constraints.");
        } else if (opt.fail.ierr == 4 && opt.fail.ifmt == 1) {
          opt.fail.set_errorid(4, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "Too many major iterations.");
        } else if (opt.fail.ierr == 6 && opt.fail.ifmt == 1) {
          opt.fail.set_errorid(6, error_handler::ErrorCategory::Warning,
                               error_handler::ErrorType::GeneralWarning);
          opt.fail.append_msg(false, "Current point cannot be improved upon.");
        } else if (opt.fail.ierr == 7 && opt.fail.ifmt == 1) {
          opt.fail.set_errorid(7, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "Large errors found in the derivatives.");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 2) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(true, "On entry, n = ", 1, ".");
          opt.fail.append_msg(false, "Constraint: n > 0.");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 3) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(true, "On entry, nclin = ", 1, ".");
          opt.fail.append_msg(false, "Constraint: nclin >= 0.");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 4) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(true, "On entry, ncnln = ", 1, ".");
          opt.fail.append_msg(false, "Constraint: ncnln >= 0.");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 10) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry, the equal bounds on ", 1,
                              " are infinite, because");
          opt.fail.append_msg(false, "bl[", 2, "] = beta and bu[", 3,
                              "] = beta,");
          opt.fail.append_msg(false, "but abs(beta) >= bigbnd: beta = ", 4,
                              " and");
          opt.fail.append_msg(false, "bigbnd = ", 5, ".");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 11) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry, the bounds on ", 1,
                              " are inconsistent:");
          opt.fail.append_msg(false, "bl[", 2, "] = ", 3, " and");
          opt.fail.append_msg(false, "bu[", 4, "] = ", 5, ".");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 14) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry with a Warm Start,");
          opt.fail.append_msg(false, "istate[", 1, "] = ", 2, ".");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 120) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry, the equal bounds on variable ",
                              1, " are");
          opt.fail.append_msg(false, "infinite, because bl[", 2,
                              "] = beta and");
          opt.fail.append_msg(false, "bu[", 3,
                              "] = beta, but abs(beta) >= bigbnd:");
          opt.fail.append_msg(false, "beta = ", 4, " and bigbnd = ", 5, ".");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 121) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false,
                              "On entry, the equal bounds on linear "
                              "constraint ",
                              1, " are");
          opt.fail.append_msg(false, "infinite, because bl[", 2,
                              "] = beta and");
          opt.fail.append_msg(false, "bu[", 3,
                              "] = beta, but abs(beta) >= bigbnd:");
          opt.fail.append_msg(false, "beta = ", 4, " and bigbnd = ", 5, ".");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 122) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(
            false, "On entry, the equal bounds on nonlinear constraint ", 1);
          opt.fail.append_msg(false, "are infinite, because bl[", 2,
                              "] = beta and");
          opt.fail.append_msg(false, "bu[", 3,
                              "] = beta, but abs(beta) >= bigbnd:");
          opt.fail.append_msg(false, "beta = ", 4, " and bigbnd = ", 5, ".");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 130) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false, "On entry, the bounds on variable ", 1,
                              " are");
          opt.fail.append_msg(false, "inconsistent: bl[", 2, "] = ", 3);
          opt.fail.append_msg(false, "and bu[", 4, "] = ", 5, ".");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 131) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false,
                              "On entry, the bounds on linear constraint ", 1,
                              " are");
          opt.fail.append_msg(false, "inconsistent: bl[", 2, "] = ", 3);
          opt.fail.append_msg(false, "and bu[", 4, "] = ", 5, ".");
        } else if (opt.fail.ierr == 9 && opt.fail.ifmt == 132) {
          opt.fail.set_errorid(9, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(false,
                              "On entry, the bounds on nonlinear constraint ",
                              1, " are");
          opt.fail.append_msg(false, "inconsistent: bl[", 2, "] = ", 3);
          opt.fail.append_msg(false, "and bu[", 4, "] = ", 5, ".");
        } else {
          opt.fail.set_unexpected_error();
        }
        opt.fail.throw_error();
      }
      if (opt.fail.error_thrown) {
        return;
      }

      local_istate.copy_back(istate);
      if (local_ncnln != 0) {
        local_c.copy_back(c);
      }
      if (local_ncnln != 0) {
        local_cjac.copy_back(cjac);
      }
      local_clamda.copy_back(clamda);
      local_objgrd.copy_back(objgrd);
      local_r.copy_back(r);
      local_x.copy_back(x);
      opt.fail.throw_warning();
    }

    // alt-1
    template <typename A, typename BL, typename BU, typename CONFUN,
              typename OBJFUN, typename ISTATE, typename C, typename CJAC,
              typename CLAMDA, typename OBJGRD, typename R, typename X,
              typename COMM>
    void nlp1_solve(const A &a, const BL &bl, const BU &bu, CONFUN &&confun,
                    OBJFUN &&objfun, types::f77_integer &itera, ISTATE &&istate,
                    C &&c, CJAC &&cjac, CLAMDA &&clamda, double &objf,
                    OBJGRD &&objgrd, R &&r, X &&x, COMM &comm) {
      opt::OptionalE04UC local_opt;

      nlp1_solve(a, bl, bu, confun, objfun, itera, istate, c, cjac, clamda,
                 objf, objgrd, r, x, comm, local_opt);
    }
  }
}
#define e04uc opt::nlp1_solve
#endif
