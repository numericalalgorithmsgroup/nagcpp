// Header for nagcpp::sparse::direct_real_gen_matmul (f11mk)

// Copyright 2024, Numerical Algorithms Group Ltd, Oxford, UK.
// Generated by cpp-ft-wrapper.xsl
// Version 30.1.0.0
#ifndef NAGCPP_F11MK_HPP
#define NAGCPP_F11MK_HPP

#include "utility/nagcpp_consts.hpp"
#include "utility/nagcpp_data_handling.hpp"
#include "utility/nagcpp_engine_routines.hpp"
#include "utility/nagcpp_engine_types.hpp"
#include "utility/nagcpp_error_handler.hpp"
#include "utility/nagcpp_utility_optional.hpp"
#include <algorithm>
#include <cmath>

namespace nagcpp {
  namespace sparse {
    // direct_real_gen_matmul (f11mk)
    // Real sparse nonsymmetric matrix-matrix multiply, compressed column storage.
    // sparse::direct_real_gen_matmul (f11mk) computes a matrix-matrix or
    // transposed matrix-matrix product involving a real, square, sparse
    // nonsymmetric matrix stored in compressed column (Harwell--Boeing) format.

    // parameters:
    //   trans: std::string, scalar
    //     Specifies whether or not the matrix A is transposed
    //   beta: double, scalar
    //     The scalar factor beta
    //   c: double, array, shape(n, m)
    //     Optionally, on entry: the n*m matrix C
    //     On exit, if not null on entry: C is overwritten by alpha AB+beta C or
    //     alpha A^TB+beta C depending on the value of trans
    //   n: types::f77_integer, scalar
    //     n, the order of the matrix A
    //   m: types::f77_integer, scalar
    //     m, the number of columns of matrices B and C
    //   alpha: double, scalar
    //     alpha, the scalar factor in the matrix multiplication
    //   icolzp: types::f77_integer, array, shape(n+1)
    //     The new column index array of sparse matrix A
    //   irowix: types::f77_integer, array, shape(asize)
    //     The row index array of sparse matrix A
    //   a: double, array, shape(asize)
    //     The array of nonzero values in the sparse matrix A
    //   b: double, array, shape(n, m)
    //     The n*m matrix B
    //   opt: sparse::OptionalF11MK
    //     Optional parameter container, derived from utility::Optional.
    //     contains:
    //       fail: error_handler::ErrorHandler

    // error_handler::ErrorException
    //   (errorid 1)
    //     On entry, m = <value>.
    //     Constraint: m >= 0.
    //   (errorid 1)
    //     On entry, n = <value>.
    //     Constraint: n >= 0.
    //   (errorid 1)
    //     On entry, trans = "<value>".
    //     Constraint: trans = "N" or "T".
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     Supplied argument has <value> dimensions.
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     Supplied argument was a vector of size <value>.
    //   (errorid 10601)
    //     On entry, argument <value> must be a vector of size <value> array.
    //     The size for the supplied array could not be ascertained.
    //   (errorid 10601)
    //     On entry, argument <value> must be a <value> x <value> array.
    //     Supplied argument has <value> dimensions.
    //   (errorid 10601)
    //     On entry, argument <value> must be a <value> x <value> array.
    //     Supplied argument was a <value> x <value> array.
    //   (errorid 10601)
    //     On entry, argument <value> must be a <value> x <value> array.
    //     Not all of the sizes for the supplied array could be ascertained.
    //   (errorid 10602)
    //     On entry, the raw data component of <value> is null.
    //   (errorid 10603)
    //     On entry, unable to ascertain a value for <value>.
    //   (errorid 10604)
    //     On entry, the data in <value> is stored in <value> Major Order.
    //     The data was expected to be in <value> Major Order.
    //   (errorid -99)
    //     An unexpected error has been triggered by this routine.
    //   (errorid -399)
    //     Your licence key may have expired or may not have been installed correctly.
    //   (errorid -999)
    //     Dynamic memory allocation failed.

    extern "C" {
#if defined(_WIN32) && defined(USE_STDCALL)
#define f11mkft_(en_data, trans, n, m, alpha, icolzp, irowix, a, b, ldb, beta, \
                 c, ldc, errbuf, ifail, trans_length, errbuf_length)           \
  F11MKFT(en_data, trans, trans_length, n, m, alpha, icolzp, irowix, a, b,     \
          ldb, beta, c, ldc, errbuf, errbuf_length, ifail)
#elif defined(_WIN32) || defined(_WIN64)
#define f11mkft_ F11MKFT
#else
#define F11MKFT f11mkft_
#endif
    extern void NAG_CALL
      F11MKFT(types::engine_data &en_data,
              const char *trans NAG_STDCALL_LEN(trans_length),
              const types::f77_integer &n, const types::f77_integer &m,
              const double &alpha, const types::f77_integer icolzp[],
              const types::f77_integer irowix[], const double a[],
              const double b[], const types::f77_integer &ldb,
              const double &beta, double c[], const types::f77_integer &ldc,
              char *errbuf NAG_STDCALL_LEN(errbuf_length),
              types::f77_integer &ifail NAG_NSTDCALL_LEN(trans_length)
                NAG_NSTDCALL_LEN(errbuf_length));
    }

    class OptionalF11MK : public utility::Optional {
    public:
      OptionalF11MK() : Optional() {}
      template <typename ICOLZP, typename IROWIX, typename A, typename B,
                typename C>
      friend void
        direct_real_gen_matmul(const std::string trans, const double alpha,
                               const ICOLZP &icolzp, const IROWIX &irowix,
                               const A &a, const B &b, const double beta, C &&c,
                               sparse::OptionalF11MK &opt);
    };

    template <typename ICOLZP, typename IROWIX, typename A, typename B,
              typename C>
    void direct_real_gen_matmul(const std::string trans, const double alpha,
                                const ICOLZP &icolzp, const IROWIX &irowix,
                                const A &a, const B &b, const double beta,
                                C &&c, sparse::OptionalF11MK &opt) {
      opt.fail.prepare("sparse::direct_real_gen_matmul (f11mk)");
      types::engine_data en_data;
      engine_routines::y90haan_(en_data);
      en_data.allocate_workspace = constants::NAG_ED_YES;
      data_handling::RawData<types::f77_integer,
                             data_handling::ArgIntent::IntentIN,
                             typename std::remove_reference<ICOLZP>::type>
        local_icolzp(icolzp);
      data_handling::RawData<types::f77_integer,
                             data_handling::ArgIntent::IntentIN,
                             typename std::remove_reference<IROWIX>::type>
        local_irowix(irowix);
      data_handling::RawData<double, data_handling::ArgIntent::IntentIN,
                             typename std::remove_reference<A>::type>
        local_a(a);
      data_handling::RawData<double, data_handling::ArgIntent::IntentIN,
                             typename std::remove_reference<B>::type>
        local_b(b);
      data_handling::RawData<double, data_handling::ArgIntent::IntentINOUT,
                             typename std::remove_reference<C>::type>
        local_c(c);

      data_handling::StringRawData<data_handling::ArgIntent::IntentIN>
        local_trans(trans);
      types::f77_integer local_n =
        data_handling::get_size(opt.fail, "n", local_b, 1, local_c, 1);
      if (opt.fail.error_thrown) {
        return;
      }
      types::f77_integer local_m =
        data_handling::get_size(opt.fail, "m", local_b, 2, local_c, 2);
      if (opt.fail.error_thrown) {
        return;
      }
      types::f77_integer vl_asize;
      if (local_n >= 0) {
        vl_asize = local_icolzp((local_n + 1) - 1) - 1;
      } else {
        vl_asize = 0;
      }
      if (!(local_c.data)) {
        if (std::abs(beta) > 0) {
          opt.fail.raise_error_array_null("c");
          if (opt.fail.error_thrown) {
            return;
          }
        }
        local_c.resize(c, local_n, local_m);
      }
      types::f77_integer local_storage_order =
        data_handling::get_storage_order(opt.default_to_col_major, local_b,
                                         local_c);
      en_data.storage_order = local_storage_order;

      types::f77_integer local_ldc =
        std::max(static_cast<types::f77_integer>(1),
                 local_c.get_LD(local_storage_order));
      local_c.check(opt.fail, "c", true, local_storage_order, local_n, local_m);
      if (opt.fail.error_thrown) {
        return;
      }
      types::f77_integer local_ldb =
        std::max(static_cast<types::f77_integer>(1),
                 local_b.get_LD(local_storage_order));
      local_b.check(opt.fail, "b", true, local_storage_order, local_n, local_m);
      if (opt.fail.error_thrown) {
        return;
      }
      local_a.check(opt.fail, "a", true, vl_asize);
      if (opt.fail.error_thrown) {
        return;
      }
      local_irowix.check(opt.fail, "irowix", true, vl_asize);
      if (opt.fail.error_thrown) {
        return;
      }
      local_icolzp.check(opt.fail, "icolzp", true, local_n + 1);
      if (opt.fail.error_thrown) {
        return;
      }

      f11mkft_(en_data, local_trans.data, local_n, local_m, alpha,
               local_icolzp.data, local_irowix.data, local_a.data, local_b.data,
               local_ldb, beta, local_c.data, local_ldc, opt.fail.errbuf,
               opt.fail.errorid, local_trans.string_length,
               opt.fail.errbuf_length);

      if (!(opt.fail.initial_error_handler(en_data))) {
        if (opt.fail.ierr == 1 && opt.fail.ifmt == -3) {
          opt.fail.set_errorid(1, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(true, "On entry, m = ", ".");
          opt.fail.append_msg(false, "Constraint: m >= 0.");
        } else if (opt.fail.ierr == 1 && opt.fail.ifmt == -2) {
          opt.fail.set_errorid(1, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(true, "On entry, n = ", ".");
          opt.fail.append_msg(false, "Constraint: n >= 0.");
        } else if (opt.fail.ierr == 1 && opt.fail.ifmt == -1) {
          opt.fail.set_errorid(1, error_handler::ErrorCategory::Error,
                               error_handler::ErrorType::GeneralError);
          opt.fail.append_msg(true, "On entry, trans = \"" + trans + "\".");
          opt.fail.append_msg(false, "Constraint: trans = \"N\" or \"T\".");
        } else {
          opt.fail.set_unexpected_error();
        }
        opt.fail.throw_error();
      }
      if (opt.fail.error_thrown) {
        return;
      }

      local_c.copy_back(c);
      opt.fail.throw_warning();
    }

    // alt-1
    template <typename ICOLZP, typename IROWIX, typename A, typename B,
              typename C>
    void direct_real_gen_matmul(const std::string trans, const double alpha,
                                const ICOLZP &icolzp, const IROWIX &irowix,
                                const A &a, const B &b, const double beta,
                                C &&c) {
      sparse::OptionalF11MK local_opt;

      direct_real_gen_matmul(trans, alpha, icolzp, irowix, a, b, beta, c,
                             local_opt);
    }
  }
}
#define f11mk sparse::direct_real_gen_matmul
#endif
